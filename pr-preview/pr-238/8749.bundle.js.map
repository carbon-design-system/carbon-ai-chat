{"version":3,"file":"8749.bundle.js","mappings":"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","sources":["webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/utils/lang/stringUtils.js","webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/utils/lang/langUtils.js","webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/components/responseTypes/util/SearchResultBody.js","webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/components/responseTypes/util/citations/ViewSourcePanel.js"],"sourcesContent":["import { consoleError } from '../miscUtils.js';\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\n/**\n * Determines if the given string is a \"empty\" string. That is a string that has no value or is the literal string\n * \"null\".\n */\nfunction isEmptyString(value) {\n    return !value || value === \"null\";\n}\n/**\n * Attempts to parse the given value into a JSON object. Returns a boolean indicating success.\n */\nfunction isJsonString(data) {\n    try {\n        JSON.parse(data);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nfunction parseUnknownDataToMarkdown(data) {\n    let content;\n    if (data) {\n        try {\n            if (typeof data === \"object\") {\n                content = `\\`\\`\\`\\n${JSON.stringify(data, null, 2)}\\n\\`\\`\\`\\n`;\n            }\n            else if (typeof data === \"string\") {\n                if (isJsonString(data)) {\n                    content = `\\`\\`\\`\\n${JSON.stringify(JSON.parse(data), null, 2)}\\n\\`\\`\\`\\n`;\n                }\n                else {\n                    content = data;\n                }\n            }\n            else {\n                content = String(data);\n            }\n            return content;\n        }\n        catch (e) {\n            consoleError(\"Cannot parse step content\", e);\n        }\n    }\n    return undefined;\n}\n/**\n * Sometimes we are passed back \"null\" as a string! In that case, instead of showing \"null\" as a title or body, we\n * convert it to a real null value.\n *\n * @param str A string for the title or body of the search card.\n */\nfunction convertToEmptyStringIfStringifiedNull(str) {\n    return str === \"null\" ? null : str;\n}\n/**\n * Under the covers before it gets to us, a title/body may have been a stringified array. We need to remove the [\"\"]\n * if that is the case.\n *\n * @param str A string for the title or body of the search card.\n */\nfunction convertPossibleStringifiedArrayToFirstString(str) {\n    if (typeof str === \"string\" && str.startsWith('[\"') && str.endsWith('\"]')) {\n        try {\n            [str] = JSON.parse(str);\n        }\n        catch (error) {\n            // Not an array of strings, so do nothing.\n        }\n    }\n    return str;\n}\n\nexport { convertPossibleStringifiedArrayToFirstString, convertToEmptyStringIfStringifiedNull, isEmptyString, parseUnknownDataToMarkdown };\n","/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\n/**\n * Miscellaneous JavaScript utilities.\n */\n/**\n * Determines if the given value is null or undefined.\n */\nfunction isNil(value) {\n    return value === undefined || value === null;\n}\n/**\n * Determines if a given number is odd.\n */\nfunction isOdd(value) {\n    if (value % 2 !== 1) {\n        return true;\n    }\n    return false;\n}\n\nexport { isNil, isOdd };\n","import React from 'react';\nimport { isOdd } from '../../../utils/lang/langUtils.js';\nimport { convertPossibleStringifiedArrayToFirstString, convertToEmptyStringIfStringifiedNull } from '../../../utils/lang/stringUtils.js';\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\n/**\n * Returns a {@link ReactNode} that represents the given text with `<em>` tags in the string replaced with actual\n * JSX elements to form highlighted portions.\n */\nfunction formatHighlightFields(str) {\n    const strArray = str.split(new RegExp(\"<em>|</em>\", \"g\"));\n    // If there is an odd number of '<em>' separators, then just return the whole string, minus the '<em>' elements.\n    if (isOdd(strArray.length)) {\n        return [strArray.join(\"\")];\n    }\n    return strArray.map((strSegment, index) => {\n        if (isOdd(index)) {\n            return strSegment;\n        }\n        return (\n        // eslint-disable-next-line react/no-array-index-key\n        React.createElement(\"em\", { key: index, className: \"WAC__highlight\" }, strSegment));\n    });\n}\n/**\n * Determine which element to render as the body and the amount of text that will be displayed in it.\n * Always use highlight.body, Use body as a fallback based on certain conditions\n * This was driven by https://github.ibm.com/Watson-Discovery/customer-care/issues/660\n * We check the searchResults.highlight.body which should be an array. If that is not set, we fall back to\n * searchResult.body which is either a string OR a stringified array. If it is the latter, we only want the first\n * item in the stringified array. https://github.ibm.com/watson-engagement-advisor/wea-backlog/issues/31262 has an\n * explanation.\n */\nfunction SearchResultBody({ searchResult }) {\n    if (searchResult && \"highlight\" in searchResult) {\n        if (searchResult.highlight?.body?.[0]) {\n            return formatHighlightFields(convertToEmptyStringIfStringifiedNull(searchResult.highlight.body[0]));\n        }\n    }\n    if (searchResult && \"body\" in searchResult && searchResult.body) {\n        return convertPossibleStringifiedArrayToFirstString(convertToEmptyStringIfStringifiedNull(searchResult.body));\n    }\n    return null;\n}\nconst SearchResultBodyExport = React.memo(SearchResultBody);\n/**\n * In conversational search citation panels we show the search result body instead of the citation text or highlight\n * body because it will contain the most context for the user. This will only be used if there is no url or\n * pdf attached to the source, so the assumption is that the data will be nicely formatted from document ingestion\n * instead of a web crawler. We also make sure to highlight the citation text within the search result body to help the\n * user find the citation.\n */\nfunction SearchResultBodyWithCitationHighlighted({ relatedSearchResult, citationItem, }) {\n    const elementsArray = [];\n    let searchString;\n    let citationString;\n    if (relatedSearchResult?.body) {\n        const searchStringFromBody = convertPossibleStringifiedArrayToFirstString(convertToEmptyStringIfStringifiedNull(relatedSearchResult.body));\n        // Search result body's can contain <em> and </em> tags which need to be removed. After remove the em tags, it\n        // should be safe to assume that the citation text is a direct substring of either the search_result body or title.\n        searchString = searchStringFromBody\n            .replace(\"<em>\", \"\")\n            .replace(\"</em>\", \"\");\n    }\n    if (citationItem?.text) {\n        citationString = convertPossibleStringifiedArrayToFirstString(convertToEmptyStringIfStringifiedNull(citationItem.text));\n    }\n    if (searchString && citationString) {\n        const startOfCitation = searchString.indexOf(citationString);\n        // If the citation string is not within the search string from the search_result body than the citation was from the\n        // search_result title which doesn't get this highlight treatment.\n        if (startOfCitation !== -1) {\n            // Add the text prior to the citation to the array.\n            elementsArray.push(React.createElement(\"span\", { key: 1 }, searchString.substring(0, startOfCitation)));\n            // Add the highlighted citation text to the array.\n            elementsArray.push(React.createElement(\"em\", { key: 2, className: \"WAC__highlight\" }, searchString.substring(startOfCitation, startOfCitation + citationString.length)));\n            // Add the text after the citation to the array.\n            elementsArray.push(React.createElement(\"span\", { key: 3 }, searchString.substring(startOfCitation + citationString.length)));\n        }\n    }\n    if (elementsArray.length) {\n        // If we had a search string and a citation string then we were able to form a highlighted search body which should\n        // be used.\n        return elementsArray;\n    }\n    if (searchString.length) {\n        // If we couldn't form a highlighted search body then just use the search string. This could happen if the citation\n        // string was in the title of the search_result instead of in the body.\n        return [React.createElement(\"span\", { key: \"search-string\" }, searchString)];\n    }\n    // If for some reason we couldn't create a search string then use the citation string.\n    return [React.createElement(\"span\", { key: \"citation-string\" }, citationString)];\n}\nconst SearchResultBodyWithCitationHighlightedExport = React.memo(SearchResultBodyWithCitationHighlighted);\n\nexport { SearchResultBodyExport as SearchResultBody, SearchResultBodyWithCitationHighlightedExport as SearchResultBodyWithCitationHighlighted };\n","import React, { forwardRef } from 'react';\nimport { useSelector } from 'react-redux';\nimport { useLanguagePack } from '../../../../hooks/useLanguagePack.js';\nimport { useServiceManager } from '../../../../hooks/useServiceManager.js';\nimport actions from '../../../../store/actions.js';\nimport { BasePanelComponent as BasePanelComponentExport } from '../../../BasePanelComponent.js';\nimport { SearchResultBodyWithCitationHighlighted as SearchResultBodyWithCitationHighlightedExport, SearchResultBody as SearchResultBodyExport } from '../SearchResultBody.js';\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\n/**\n * This panel is used to show the text of a conversational search citation.\n */\nfunction ViewSourcePanel(props, ref) {\n    const languagePack = useLanguagePack();\n    const { store } = useServiceManager();\n    const { isOpen, citationItem, relatedSearchResult } = useSelector((state) => state.viewSourcePanelState);\n    let content;\n    if (citationItem && \"text\" in citationItem) {\n        // If text is in the citation item then this is a conversational search source that is being shown.\n        if (relatedSearchResult) {\n            // If there is a related search result than show the search result body with the citation text highlighted.\n            content = (React.createElement(SearchResultBodyWithCitationHighlightedExport, { relatedSearchResult: relatedSearchResult, citationItem: citationItem }));\n        }\n        else {\n            // If there is no related search result than show the citation text.\n            content = citationItem.text;\n        }\n    }\n    else {\n        // If the citation is not for a conversational search response then it must be for a legacy search result so we\n        // should show the search result body.\n        content = React.createElement(SearchResultBodyExport, { searchResult: citationItem });\n    }\n    return (React.createElement(BasePanelComponentExport, { ...props, ref: ref, className: \"WACViewSourcePanel\", isOpen: isOpen, onClickBack: () => store.dispatch(actions.setViewSourcePanelIsOpen(false)), title: citationItem?.title, labelBackButton: languagePack.general_ariaCloseInformationOverlay, eventName: \"Search citation panel opened\", eventDescription: \"A user has opened the search citation panel\" },\n        React.createElement(\"div\", { className: \"WACViewSourcePanel__Content\" }, content)));\n}\nconst ViewSourcePanelExport = forwardRef(ViewSourcePanel);\n\nexport { ViewSourcePanelExport as ViewSourcePanel };\n"],"names":["isEmptyString","value","parseUnknownDataToMarkdown","data","content","JSON","stringify","parse","e","isJsonString","String","consoleError","convertToEmptyStringIfStringifiedNull","str","convertPossibleStringifiedArrayToFirstString","startsWith","endsWith","error","isNil","isOdd","SearchResultBody","searchResult","highlight","body","strArray","split","RegExp","length","join","map","strSegment","index","React","key","className","formatHighlightFields","SearchResultBodyExport","SearchResultBodyWithCitationHighlighted","relatedSearchResult","citationItem","elementsArray","searchString","citationString","replace","text","startOfCitation","indexOf","push","substring","SearchResultBodyWithCitationHighlightedExport","ViewSourcePanel","props","ref","languagePack","useLanguagePack","store","useServiceManager","isOpen","useSelector","state","viewSourcePanelState","BasePanelComponentExport","onClickBack","dispatch","actions","setViewSourcePanelIsOpen","title","labelBackButton","general_ariaCloseInformationOverlay","eventName","eventDescription","ViewSourcePanelExport","forwardRef"],"sourceRoot":""}