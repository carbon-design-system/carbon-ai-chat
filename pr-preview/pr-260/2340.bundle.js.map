{"version":3,"file":"2340.bundle.js","mappings":";6WAyBI,SAASA,EAAOC,EAAeC,GACjC,MAAO,CACLD,cAAeA,EACfC,gBAAiBA,EAErB,CAEAC,eAAeC,EAA6BC,EAAkBC,EAAgBC,EAAqBC,GAAa,GAC9G,MAAMC,ECxBJ,SAAwCJ,EAAkBE,EAAqBG,GACjF,MAAMC,EAAOJ,GAAqBK,SAClC,IAAIC,EACJ,OAAQR,GACP,KAAKS,EAAAA,GAAsBC,mBAExBF,EAAaF,EAAO,wBAA0B,0BAC9C,MAGH,KAAKG,EAAAA,GAAsBE,eAExBH,EAAa,4BACb,MAGH,KAAKC,EAAAA,GAAsBG,sBAExBJ,EAAaF,EAAO,sBAAwB,4BAC5C,MAGH,KAAKG,EAAAA,GAAsBI,uBAExBL,EAAaF,EAAO,uBAAyB,6BAC7C,MAGH,KAAKG,EAAAA,GAAsBK,wBAExBN,EAAaF,EAAO,qBAAuB,2BAC3C,MAGH,KAAKG,EAAAA,GAAsBM,gBAExBP,EAAa,qBACb,MAGH,KAAKC,EAAAA,GAAsBO,eAExBR,EAAa,6BACb,MAGH,KAAKC,EAAAA,GAAsBQ,aAExBT,EAAa,qBACb,MAGH,KAAKC,EAAAA,GAAsBS,YAExBV,EAAa,oBACb,MAGH,KAAKC,EAAAA,GAAsBU,kBAExBX,EAAa,yBACb,MAGH,KAAKC,EAAAA,GAAsBW,iBAExBZ,EAAa,wBACb,MAGH,KAAKC,EAAAA,GAAsBY,iBAExBb,EAAa,wBACb,MAGH,KAAKC,EAAAA,GAAsBa,kBAExBd,EAAa,yBACb,MAGH,KAAKC,EAAAA,GAAsBc,cAExBf,EAAa,qBACb,MAGH,QACC,MAAO,GAET,OAAOA,GAAcH,EAAKmB,cAAc,CACtCC,GAAIjB,GACH,CACDkB,WAAYpB,GAEhB,CDxEeqB,CAA+B3B,EAAkBE,EAAqBD,EAAeI,MAC5FuB,EAASC,EAAoC7B,IAC5CH,gBAAiBA,EAAiBiC,aAAcA,GAAgBF,EAqBvE,OApBAE,EAAaC,KAAK3B,KAAOA,EACrBF,IACGL,EAAgBmC,UACnBnC,EAAgBmC,QAAU,CAAC,GAE7BnC,EAAgBmC,QAAQC,sBAAwB/B,GAE9CC,SACIF,EAAeiC,KAAK,CACxBC,KAAMC,EAAAA,GAAaC,wBACnBC,KAAMzC,KAGV0C,EAAAA,EAAAA,GAAW1C,GACPM,SACIF,EAAeiC,KAAK,CACxBC,KAAMC,EAAAA,GAAaI,oBACnBF,KAAMzC,IAGH+B,CACT,CAEA,SAASC,EAAoC7B,GAC3C,MAAMyC,EAAc,CAClBC,cAAeC,EAAAA,GAAqBC,KACpCC,mBAAoB7C,GAEhBH,GAAkBiD,EAAAA,EAAAA,IAA6BL,GAErD,MAAO,CACLX,cAFmBiB,EAAAA,EAAAA,IAAsBN,EAAa5C,GAGtDA,gBAAiBA,EAErB,CAeAC,eAAekD,EAAYC,EAAcC,EAAeC,EAAkBC,EAAkBnD,GACtFmD,SACIC,EAAAA,EAAAA,IAAaJ,EAAcnD,OAAQF,cAAeA,EAAeC,gBAAiBA,YAChFwD,EAAAA,EAAAA,IAAazD,EAAeE,MAAOgC,EAAcwB,WAC/CrD,EAAesD,QAAQC,+BAA+B1B,EAAcjC,GAC1EI,EAAewD,MAAMC,SAASH,EAAAA,GAAQI,oBAAoB7B,EAAcjC,EAA2B,IAAVyD,OAIjG,CAEAxD,eAAe8D,EAAoBC,EAAgBC,EAAc7D,GAC/D,MAAM8D,EAzBR,SAAgCC,GAC9B,MAAOC,kBAAmBA,GAAqBD,EAC/C,IAAKC,EACH,OAAO,KAET,MAAOpE,gBAAiBA,EAAiBiC,aAAcA,GAAgBD,EAAoC,MAE3G,OADAC,EAAaC,KAAK3B,KAAO6D,EAClB,CACLpE,gBAAiBA,EACjBiC,aAAcA,EAElB,CAcoBoC,CAAuBjE,EAAewD,MAAMU,WAAWH,cACzE,GAAID,EAAW,CACb,MAAMK,EAAsBnE,EAAeoE,cAC3CC,EAAAA,EAAAA,IAAsB,KAChBF,IAAwBnE,EAAeoE,cACzCrB,EAAY,CAAErD,EAAO,CAAEoE,EAAUjC,cAAgBiC,EAAUlE,kBAAoB,EAAM,GAAQiE,EAAc7D,IAE5G4D,EACL,CACF,CAEA/D,eAAeyE,EAA4BvE,EAAkBE,EAAqBC,EAAY2D,EAAc7D,GAC1G,MAAMuE,QAAuBzE,EAA6BC,EAAkBC,EAAgBC,EAAqBC,SAC3G6C,EAAY,CAAErD,EAAO,CAAE6E,EAAe1C,cAAgB0C,EAAe3E,kBAAoB,EAAM,GAAQiE,EAAc7D,EAC7H,C,cEpEI,MAUGwE,UAAWA,EAAWvD,YAAaA,EAAaD,aAAcA,EAAcJ,uBAAwBA,EAAwBH,mBAAoBA,EAAoBK,gBAAiBA,EAAiBC,eAAgBA,EAAgBF,wBAAyBA,EAAyBF,sBAAuBA,EAAuBD,eAAgBA,EAAgBW,kBAAmBA,EAAmBD,iBAAkBA,EAAkBD,iBAAkBA,EAAkBD,kBAAmBA,EAAmBI,cAAeA,GAAiBd,EAAAA,GAEjiB,MAAMiE,EACJC,WAAAA,CAAY1E,GACV2E,KAAKC,aAAc,EACnBD,KAAKE,0BAA2B,EAChCF,KAAKG,oBAAqB,EAC1BH,KAAKI,eAAiB,IAAIC,IAC1BL,KAAKM,kBAAmB,EACxBN,KAAK3E,eAAiBA,CACxB,CACAkF,wBAAAA,GACE,OAAOP,KAAK3E,eAAewD,MAAMU,WAAWiB,OAAOC,OAAOC,mBAAqBV,KAAKW,YAAYC,iBAAcC,CAChH,CACA,gBAAMC,GACJ,GAAId,KAAKW,YACP,MAAM,IAAII,MAAM,4CAElB,MAAOlC,MAAOA,EAAOmC,SAAUA,GAAYhB,KAAK3E,eAC1C4F,EAAQpC,EAAMU,YACbiB,OAAQA,EAAQU,0BAA2BA,GAA6BD,EACzEE,GAAmBC,EAAAA,EAAAA,GAAUF,EAA0BG,UAAUC,gBAAgBH,kBAEvF,GADAnB,KAAKuB,oBAAsB,IAAIC,EAAwBxB,KAAK3E,eAAgB2E,MACxEQ,EAAOC,OAAOC,mBAAoB,CACpC,MAAMe,EAAa,CACjBC,SAAU1B,KAAKuB,oBACfP,SAAUA,EACVW,eAAgBR,GAElBnB,KAAKW,kBAAoBH,EAAOC,OAAOC,mBAAmBe,GAwjBhE,SAAmCd,GACjC,GAAKA,EAEE,GAA2B,iBAAhBA,GAChBiB,EAAAA,EAAAA,IAAa,mGAAmGjB,KAAgBA,OAC3H,CACiB,CAAE,YAAa,UAAW,sBAClCkB,QAAQC,IACpB,MAAMC,EAAQpB,EAAYmB,GACL,mBAAVC,IACTH,EAAAA,EAAAA,IAAa,8EAA8EE,yCAAoDC,KAAUA,EAAOpB,KAGpK,MAAMjF,EAAOiF,EAAYC,YACzB,IAAKlF,EACH,MAAMqF,MAAM,iDAEd,GAAIrF,IAAyB,iBAATA,GAAqBA,EAAKsG,OAAS,IACrD,MAAM,IAAIjB,MAAM,iCAAiCrF,mBAErD,MAlBEkG,EAAAA,EAAAA,IAAa,qFAAsFjB,EAmBvG,CA5kBMsB,CAA0BjC,KAAKW,cAC/BuB,EAAAA,EAAAA,IAAS,qCACX,CACAlC,KAAKM,kBAAoBN,KAAKW,aAAawB,SAC7C,CACA,eAAMC,CAAUC,EAAqBpH,GACnC,IAAK+E,KAAKW,YACR,MAAM,IAAII,MAAM,2CAKlB,GAHIf,KAAK3E,eAAewD,MAAMU,WAAW2B,0BAA0BG,UAAUC,gBAAgBgB,mBACrFtC,KAAKuC,SAAQ,GAAM,GAAM,GAE7BvC,KAAKC,YACP,MAAM,IAAIc,MAAM,0FAElB,MAAO1F,eAAgBA,GAAkB2E,KACzC,IACEA,KAAKC,aAAc,EACnBD,KAAKG,oBAAqB,EAC1BH,KAAKI,eAAeoC,QACpBxC,KAAK3E,eAAewD,MAAMC,UAAS2D,EAAAA,EAAAA,IAA4BzC,KAAKI,eAAesC,KAAO,IAC1F,MAAMC,EAAQ,CACZpF,KAAMC,EAAAA,GAAaoF,2BACnBC,QAAS5H,GAGX,SADMI,EAAeiC,KAAKqF,GACtBA,EAAMG,gBAIR,OAHA9C,KAAKC,aAAc,QACbD,KAAK+C,aAAY,GAAO,QAC9B1H,EAAewD,MAAMC,UAASkE,EAAAA,EAAAA,KAAgB,EAAO,OAGvD,MAAMC,EAAmB5H,EAAewD,MAAMU,WAAWiB,OAAOC,OAAOE,aAAauC,wBAChFD,IACFjD,KAAKmD,gCAAkCC,WAAW,IAAMpD,KAAKqD,gCAAoD,IAAnBJ,IAEhG5H,EAAewD,MAAMC,UAASkE,EAAAA,EAAAA,KAAgB,EAAMX,EAAoBiB,SAASzG,WAC3EmD,KAAKW,YAAYyB,UAAUnH,EAAiB,CAChDsI,oBAAqBZ,EAAMY,qBAE/B,CAAE,MAAOC,GAWP,MAVA5B,EAAAA,EAAAA,IAAa,uDAAwD4B,GACjExD,KAAKuB,2BACDvB,KAAKuB,oBAAoBkC,eAAe,CAC5ClG,KAAMmG,EAAAA,GAAUC,WAChBC,QAASJ,IAGbnI,EAAewD,MAAMC,UAASkE,EAAAA,EAAAA,KAAgB,EAAO,OACrDhD,KAAKC,aAAc,EACnBD,KAAK6D,8BACCL,CACR,CACF,CACA,oBAAMM,CAAeC,GACnB,MAAMpB,EAAQ,CACZpF,KAAMC,EAAAA,GAAawG,yBACnBD,kBAAmBA,EACnBE,kBAAmB,KACnBC,eAAe,GAGjB,aADMlE,KAAK3E,eAAeiC,KAAKqF,GACxBA,CACT,CACA,iBAAMI,CAAYgB,EAAmBI,SAC7BnE,KAAK3E,eAAeiC,KAAK,CAC7BC,KAAMC,EAAAA,GAAa4G,qBACnBL,kBAAmBA,EACnBI,iBAAkBA,GAEtB,CACA,aAAM5B,CAAQ8B,EAAaC,GAA4B,EAAMC,GAAuB,GAClF,IAAKvE,KAAKC,cAAgBD,KAAKW,YAC7B,OAEF,MAAO6D,YAAaA,GAAexE,KAAKyE,2BACxC,IAAI9B,EACJ,GAAI6B,IACF7B,QAAc3C,KAAK8D,gBAAe,GAC9BnB,EAAMuB,eACR,OAGJ,MAAMQ,EAAiBL,EAAclI,EAAkBC,QACjD4D,KAAK2E,WAAU,EAAOhC,GAAOsB,kBAAmBK,EAA2BC,EAAsBG,EACzG,CACA,eAAMC,CAAUZ,EAAmBE,EAAmBK,EAA2BC,EAAsBK,GACrG,MAAOJ,YAAaA,GAAexE,KAAKyE,2BAClCvF,EAAec,KAAKsC,cAC1BtC,KAAK6D,8BACL7D,KAAK6E,6BAA6BC,EAAAA,GAAiBC,WACnD,UACQC,EAAAA,EAAAA,GAAiBhF,KAAKW,YAAY4B,QAAQ,CAC9CwB,kBAAmBA,EACnBE,kBAAmBA,IAlIC,IAoIxB,CAAE,MAAOT,IACP5B,EAAAA,EAAAA,IAAa,uDAAwD4B,EACvE,CACA,GAAIgB,GAAeF,EAA2B,CAC5C,MAAOhJ,oBAAqBA,GAAuB0E,KAAKyE,iCAClD9E,EAA4BiF,EAAyBtJ,GAAqB,EAAM4D,EAAcc,KAAK3E,eAC3G,CACA2E,KAAKC,aAAc,EACnBD,KAAKG,oBAAqB,EAC1BH,KAAK3E,eAAewD,MAAMC,UAASyD,EAAAA,EAAAA,aAC7BvC,KAAK+C,YAAYgB,GAAoBS,GACvCA,GAAeD,SACXvF,EA5Ia,KA4IyBE,EAAcc,KAAK3E,eAEnE,CACA,wBAAM4J,CAAmBzJ,EAAM0J,GAC7B,IAAKlF,KAAKW,cAAgBX,KAAKC,YAC7B,OAEF,MAAO5E,eAAgBA,GAAkB2E,MACzCrC,EAAAA,EAAAA,GAAWuH,GACX,MAAMjK,GAAkBkK,EAAAA,EAAAA,IAA4B3J,GACpDP,EAAgBmK,MAAMnH,mBAAqB4B,QACrCxE,EAAeiC,KAAK,CACxBC,KAAMC,EAAAA,GAAa6H,qBACnB3H,KAAMzC,EACNqK,MAAOJ,IAET,MAAMK,GAAcC,EAAAA,EAAAA,GAAqBvK,EAAiBA,EAAgBmK,MAAM5J,MAC1EiK,EAAiBF,EAAYjC,SAASzG,GACtC6I,EAAQ,GACVH,EAAYpI,KAAK3B,MACnBkK,EAAMC,KAAK5K,EAAO,CAAEwK,GAAetK,IAErCiK,EAAQrD,QAAQ+D,IACd,MAAMC,GAAwBC,EAAAA,EAAAA,IAAkCF,GAC1DG,GAAqBP,EAAAA,EAAAA,GAAqBK,EAAuBA,EAAsBT,MAAM5J,KAAMoK,EAAO/I,IAChH6I,EAAMC,KAAK5K,EAAO,CAAEgL,GAAsBF,IAC1C7F,KAAKI,eAAe4F,IAAIJ,EAAO/I,MAEjCmD,KAAK3E,eAAewD,MAAMC,UAAS2D,EAAAA,EAAAA,IAA4BzC,KAAKI,eAAesC,KAAO,UACpFtE,EAAYsH,EAAO,EAAM,GAAO1F,KAAKsC,cAAejH,GAC1D,IAAI4K,GAAmB,EACnBC,GAAgB,EACpB9C,WAAW,KACJ6C,GAAqBC,GACxBlG,KAAKmG,qBAAqBZ,EAAYa,cAAeC,EAAAA,EAAkBC,WAtL3C,KAyLhClD,WAAW,KACJ6C,GACHjG,KAAKmG,qBAAqBZ,EAAYa,cAAeC,EAAAA,EAAkBE,SAzLjD,KA4L1B,MAAMC,EAAiB,CACrBC,cAAevB,GAEjB,UACQlF,KAAKW,YAAYsE,mBAAmBhK,EAAiBwK,EAAgBe,GAC3EP,GAAmB,EACnBjG,KAAKmG,qBAAqBZ,EAAYa,cAAeC,EAAAA,EAAkBK,YACjErL,EAAeiC,KAAK,CACxBC,KAAMC,EAAAA,GAAamJ,iBACnBjJ,KAAMzC,EACNqK,MAAOJ,GAEX,CAAE,MAAO1B,GACP0C,GAAgB,GAChBtE,EAAAA,EAAAA,IAAa,gEAAiE4B,GAC9ExD,KAAKmG,qBAAqBZ,EAAYa,cAAeC,EAAAA,EAAkBE,OACzE,CACF,CACAK,sBAAAA,CAAuB1B,GACrB,GAAKlF,KAAKW,aAAgBX,KAAKC,YAG/B,IACED,KAAKW,YAAYiG,yBAAyB1B,EAC5C,CAAE,MAAO1B,IACP5B,EAAAA,EAAAA,IAAa,8DAA+D4B,EAC9E,CACF,CACA,sBAAMqD,GACJ,GAAK7G,KAAKW,aAAgBX,KAAKC,YAG/B,UACQD,KAAKW,YAAYkG,kBACzB,CAAE,MAAOrD,IACP5B,EAAAA,EAAAA,IAAa,8DAA+D4B,EAC9E,CACF,CACA,kCAAMsD,CAA6BC,GACjC,IAAIC,EACJ,MAAMxH,EAAsBQ,KAAK3E,eAAeoE,aAChD,GAAKO,KAAKW,aAAasG,mBAGrB,IACE,MAAMC,EAAiBlH,KAAK3E,eAAewD,MAAMU,WAAWiB,OAAOC,OAAOE,aAAawG,2BACjFC,EAAUF,EAAkC,IAAjBA,EAtOT,IAuOlBlK,QAAegI,EAAAA,EAAAA,GAAiBhF,KAAKW,YAAYsG,mBAAmBF,GAAiBK,GAEzFJ,GADa,IAAXhK,EACYqK,EAAAA,GAAwBC,QAClB,IAAXtK,EACKqK,EAAAA,GAAwBE,QAExBF,EAAAA,GAAwBG,OAE1C,CAAE,MAAOhE,IACP5B,EAAAA,EAAAA,IAAa,6CAA8C4B,GAC3DwD,EAAcK,EAAAA,GAAwBE,OACxC,MAhBAP,EAAcK,EAAAA,GAAwBG,QAwBxC,OANIhI,IAAwBQ,KAAK3E,eAAeoE,cAC9CO,KAAK3E,eAAeiC,KAAK,CACvBC,KAAMC,EAAAA,GAAaiK,kCACnBR,mBAAoBD,IAGjBA,CACT,CACA,gBAAMU,CAAWC,GACf,GAAK3H,KAAKW,aAAgBX,KAAKC,YAG/B,UACSD,KAAKW,YAAY+G,aAAaC,GACvC,CAAE,MAAOnE,IACP5B,EAAAA,EAAAA,IAAa,wDAAyD4B,EACxE,CACF,CACA2C,oBAAAA,CAAqByB,EAAWC,GAC9B7H,KAAK3E,eAAewD,MAAMC,SAASH,EAAAA,GAAQwH,qBAAqByB,EAAWC,GAC7E,CACA,mCAAMxE,GACJ,MAAMR,EAAU7C,KAAK3E,eAAewD,MAAMU,WAAWH,aAAa0I,4BAC3D7M,gBAAiBA,EAAiBiC,aAAcA,IAAgB6K,EAAAA,EAAAA,IAAiClF,SAClGzE,EAAY,CAAErD,EAAO,CAAEmC,GAAgBjC,IAAoB,EAAM,GAAQ+E,KAAKsC,cAAetC,KAAK3E,gBACxG2E,KAAKuC,SAAQ,EACf,CACAsB,2BAAAA,GACM7D,KAAKmD,kCACP6E,aAAahI,KAAKmD,iCAClBnD,KAAKmD,gCAAkC,KAE3C,CACA,mCAAM8E,CAA8BhH,GAClC,IAAKjB,KAAKyE,2BAA2BD,YACnC,OAGF,IAAIpJ,EACJ,OAFA4E,KAAK6E,6BAA6B5D,GAE1BA,GACP,KAAK6D,EAAAA,GAAiBoD,SACrB9M,EAAmBoB,EACnB,MAED,KAAKsI,EAAAA,GAAiBqD,SACrB/M,EAAmBqB,EACnB,MAED,KAAKqI,EAAAA,GAAiBC,UACrB3J,EAAmBsB,EACnB,MAED,KAAKoI,EAAAA,GAAiBsD,MACrBhN,EAAmBuB,EACnB,MAED,QACC,aAEIqD,KAAKqI,0BAA0BjN,EACvC,CACA,qBAAMkN,GACJtI,KAAK3E,eAAewD,MAAMC,UAASyJ,EAAAA,EAAAA,IAAmB,UAChDvI,KAAKqI,0BAA0B1L,SAC9BqD,KAAKW,aAAa2H,oBAC3B,CACA,qBAAME,CAAgBC,EAAgBC,GACpC,MAAO7J,MAAOA,GAASmB,KAAK3E,eAC5B,IAAIsN,GAAe,EACnB,MAAOnE,YAAaA,GAAexE,KAAKyE,2BACxC,GAAID,EAAa,CAEf,GADAxE,KAAKC,aAAc,EACfwI,GAAkBzI,KAAKW,aAAawB,UACtC,IACEtD,EAAMC,UAAS8J,EAAAA,EAAAA,KAAkB,IACjCxF,WAAWpD,KAAK3E,eAAewN,UAAUC,cACzCH,QAAqB3I,KAAKW,YAAYwB,WACxC,CAAE,MAAOqB,IACP5B,EAAAA,EAAAA,IAAa,+CAAgD4B,EAC/D,CAGF,GADA3E,EAAMC,UAAS8J,EAAAA,EAAAA,KAAkB,KAC5B5I,KAAKyE,2BAA2BD,YAEnC,YADAxE,KAAKC,aAAc,GAIrB,GADAmD,WAAWpD,KAAK3E,eAAewN,UAAUC,cACpCH,EAUH3I,KAAKM,kBAAmB,MAVP,CACjBN,KAAKC,aAAc,EACnB,MAAMf,EAAec,KAAKsC,cAE1B,GADAzD,EAAMC,UAASyD,EAAAA,EAAAA,OACXmG,EAAsB,CACxB,MAAOpN,oBAAqBA,GAAuB0E,KAAKyE,iCAClD9E,EAA4B9D,EAAAA,GAAsBO,eAAgBd,GAAqB,EAAO4D,EAAcc,KAAK3E,sBACjH2D,EAAoB,EAAGE,EAAcc,KAAK3E,eAClD,CACF,CAGF,CACF,CACAwJ,4BAAAA,CAA6B5D,GAC3BjB,KAAK3E,eAAewD,MAAMC,UAASiK,EAAAA,EAAAA,KAA0B,IACzD/I,KAAKgJ,4BACPhJ,KAAKgJ,0BAA0BC,UAAUhI,GACzCjB,KAAKgJ,0BAA4B,MAEnChJ,KAAK3E,eAAewD,MAAMC,UAASyJ,EAAAA,EAAAA,GAAmBtH,IAAU6D,EAAAA,GAAiBoD,UACnF,CACA,+BAAMG,CAA0BjN,EAAkBE,EAAqBC,GAAa,EAAM+C,GAAgB,GACnGhD,IACHA,EAAsB0E,KAAKyE,2BAA2BnJ,qBAExD,MAAO4B,aAAcA,EAAcjC,gBAAiBA,SAAyBE,EAA6BC,EAAkB4E,KAAK3E,eAAgBC,EAAqBC,SAChK6C,EAAY,CAAErD,EAAO,CAAEmC,GAAgBjC,IAAoBqD,EAAe,GAAQ0B,KAAKsC,cAAetC,KAAK3E,eACnH,CACAoJ,wBAAAA,GACE,OAAOzE,KAAK3E,eAAewD,MAAMU,WAAW2B,0BAA0BG,UAAUC,eAClF,CACAgB,WAAAA,GACE,OAAOtC,KAAK3E,eAAewD,MAAMU,WAAW2B,0BAA0BG,UAAUC,gBAAgBgB,WAClG,EAGF,MAAMd,EACJzB,WAAAA,CAAY1E,EAAgB6N,GAC1BlJ,KAAK3E,eAAiBA,EACtB2E,KAAKkJ,QAAUA,CACjB,CACAC,kBAAAA,CAAmBC,GACjBpJ,KAAK3E,eAAewD,MAAMC,UAASqK,EAAAA,EAAAA,KAAmB/H,EAAAA,EAAAA,GAAUgI,IAClE,CACA,6BAAMC,CAAwBC,GACvBtJ,KAAKkJ,QAAQjJ,aAGlBD,KAAK3E,eAAewD,MAAMC,UAASyK,EAAAA,EAAAA,IAAqBD,GAC1D,CACA,iBAAME,CAAYC,GACXzJ,KAAKkJ,QAAQjJ,cAGlBD,KAAKkJ,QAAQrF,8BACb7D,KAAK3E,eAAewD,MAAMC,UAAS4K,EAAAA,EAAAA,IAAoBD,UACjDzJ,KAAKkJ,QAAQb,0BAA0BvM,EAAoB2N,GAC7DzJ,KAAKkJ,QAAQ5I,yBACTN,KAAKkJ,QAAQb,0BAA0BtM,EAAgB,MAAM,GAAO,GAC1EiE,KAAKkJ,QAAQ5I,kBAAmB,GAEpC,CACA,uBAAMqJ,GACC3J,KAAKkJ,QAAQjJ,cAGlBiC,EAAAA,EAAAA,IAAS,8CACX,CACA,iBAAM0H,CAAYjC,GACZ3H,KAAKyE,2BAA2BD,aAAemD,IAAa3H,KAAKkJ,QAAQ/I,qBAC3EH,KAAK3E,eAAewD,MAAMC,UAAS+K,EAAAA,EAAAA,IAAoBlC,IACvD3H,KAAKkJ,QAAQ/I,mBAAqBwH,EAEtC,CACA,uBAAMmC,CAAkBjH,EAASkH,GAC/B,IAAK/J,KAAKkJ,QAAQjJ,cAAgB4C,EAChC,OAEF,MAAMmH,EAAqC,iBAAZnH,GAAuBoH,EAAAA,EAAAA,IAA6BpH,GAAWA,GAC9FqH,EAAAA,EAAAA,IAAqBF,GACjBA,EAAgBG,QAAQC,SAASpI,QACnCgI,EAAgBG,OAAOC,QAAQvI,QAAQhE,IAChCA,EAAYI,qBACfJ,EAAYI,mBAAqBpC,EAAAA,GAAsBwO,oBAI7D,MAAOhP,eAAgBA,GAAkB2E,KACzC,IAAI1E,OACYuF,IAAZkJ,EACFzO,EAAsB0E,KAAKyE,2BAA2BnJ,qBAEtDA,EAAsB0E,KAAKyE,2BAA2B6F,qBAAqBP,GACtEzO,IACHA,EAAsB0E,KAAKyE,2BAA2BnJ,oBAClDA,IACFsG,EAAAA,EAAAA,IAAa,gBAAgBmI,iGAI7B1O,EAAeiC,KAAK,CACxBC,KAAMC,EAAAA,GAAaC,wBACnBC,KAAMsM,EACN1O,oBAAqBA,IAEvB0O,EAAgB5M,QAAQC,sBAAwB/B,EAChD,MAAMN,EAAgBgP,EAAgBG,OAAOC,QAAQG,IAAIpN,IAAQgB,EAAAA,EAAAA,IAAsBhB,EAAM6M,UACvF5L,EAAY,CAAErD,EAAOC,EAAegP,IAAoB,EAAM,GAAOhK,KAAKkJ,QAAQ5G,cAAetC,KAAK3E,sBACtGA,EAAeiC,KAAK,CACxBC,KAAMC,EAAAA,GAAaI,oBACnBF,KAAMsM,EACN1O,oBAAqBA,GAEzB,CACA,iCAAMkP,CAA4Bf,GAC3BzJ,KAAKkJ,QAAQjJ,cAGdwJ,GACFzJ,KAAK3E,eAAewD,MAAMC,UAAS4K,EAAAA,EAAAA,IAAoBD,UAEnDzJ,KAAKkJ,QAAQb,0BAA0BnM,EAAyBuN,GACxE,CACA,mBAAMgB,GACCzK,KAAKkJ,QAAQjJ,oBAGZD,KAAKkJ,QAAQb,0BAA0BrM,GAC7CgE,KAAKkJ,QAAQ/I,oBAAqB,EAClCH,KAAK3E,eAAewD,MAAMC,UAAS4L,EAAAA,EAAAA,OACrC,CACA,oBAAMC,GACJ,IAAK3K,KAAKkJ,QAAQjJ,YAChB,OAEF,MAAM0C,QAAc3C,KAAKkJ,QAAQpF,gBAAe,GAC5CnB,EAAMuB,qBAGJlE,KAAKkJ,QAAQvE,WAAU,EAAMhC,EAAMsB,mBAAmB,GAAM,EAAMhI,EAC1E,CACA,oBAAMwH,CAAemH,GACnB,IAAK5K,KAAKkJ,QAAQjJ,YAChB,OAEF,MAAO1C,KAAMA,EAAMqG,QAASA,GAAWgH,GAChC/L,MAAOA,GAASmB,KAAK3E,gBACrBwP,aAAcA,GAAgBhM,EAAMU,WAAW+B,gBAStD,OARIsC,IACFhC,EAAAA,EAAAA,IAAa,+CAA+CrE,KAASqG,GAEnEiH,GAAgBD,EAAUrN,OAASmG,EAAAA,GAAUrH,cAAgBuO,EAAUE,iBACzEF,EAAY,CACVrN,KAAMmG,EAAAA,GAAUC,aAGZiH,EAAUrN,MACjB,KAAKmG,EAAAA,GAAUrH,aAERuO,EAAUE,gBACZ9K,KAAKkJ,QAAQhJ,0BAA2B,QAClCF,KAAKkJ,QAAQb,0BAA0BhM,EAAc,MAAM,GAAM,GACvEwC,EAAMC,SAASH,EAAAA,GAAQoM,iBAAiB,CACtCC,YAAY,IACX,KACMhL,KAAKkJ,QAAQhJ,2BACtBF,KAAKkJ,QAAQhJ,0BAA2B,QAClCF,KAAKkJ,QAAQb,0BAA0B/L,EAAa,MAAM,GAAM,GACtEuC,EAAMC,SAASH,EAAAA,GAAQoM,iBAAiB,CACtCC,YAAY,IACX,KAEL,MAGH,KAAKtH,EAAAA,GAAUC,WACd,CACE,MAAOvE,aAAcA,GAAgBY,KAAK3E,eAAewD,MAAMU,WACzDsD,EAAU+H,EAAUK,eAAiB7L,EAAa8L,+BACjDjQ,gBAAiBA,EAAiBiC,aAAcA,IAAgB6K,EAAAA,EAAAA,IAAiClF,SAClGzE,EAAY,CAAErD,EAAO,CAAEmC,GAAgBjC,IAAoB,EAAM,GAAQ+E,KAAKkJ,QAAQ5G,cAAetC,KAAK3E,gBAChH2E,KAAK3E,eAAewD,MAAMC,UAASkE,EAAAA,EAAAA,KAAgB,EAAO,OAC1DhD,KAAKkJ,QAAQjJ,aAAc,EAC3BD,KAAKkJ,QAAQrF,oCACP7D,KAAKkJ,QAAQnG,aAAY,EAAO8H,GACtC,KACF,CAED,KAAKnH,EAAAA,GAAUyH,aAEZnL,KAAKkJ,QAAQ/C,qBAAqByE,EAAUhD,UAAWvB,EAAAA,EAAkBE,QAI/E,CACA,yBAAM6E,CAAoBC,EAAQC,EAASC,GACzC,MAAO1M,MAAOA,GAASmB,KAAK3E,eAE5B,GADsBwD,EAAMU,WAAWiM,gBAAgBH,GAOrD,GAHwBI,EAAAA,GAAgBC,SAGpCJ,GAIF,GAHAzM,EAAMC,SAASH,EAAAA,GAAQgN,0BAA0BN,EAAQ,qBAAsBI,EAAAA,GAAgBC,WAC/F7M,EAAMC,SAASH,EAAAA,GAAQgN,0BAA0BN,EAAQ,cAAehF,EAAAA,EAAkBE,SAC1FF,EAAAA,EAAkBE,OACdgF,EAAc,CAChB,MAAOtQ,gBAAiBA,EAAiBiC,aAAcA,IAAgB6K,EAAAA,EAAAA,IAAiCwD,GACxGrO,EAAaC,KAAKc,mBAAqBpC,EAAAA,GAAsB+P,mBACvDxN,EAAY,CAAErD,EAAO,CAAEmC,GAAgBjC,IAAoB,EAAM,GAAO+E,KAAKkJ,QAAQ5G,cAAetC,KAAK3E,eACjH,OAEAwD,EAAMC,SAASH,EAAAA,GAAQgN,0BAA0BN,EAAQ,qBAAsBI,EAAAA,GAAgBI,UAC/FhN,EAAMC,SAASH,EAAAA,GAAQmN,gBAAgB,CACrClE,UAAW,0CAGN0D,GACTzM,EAAMC,SAASH,EAAAA,GAAQoN,qBAAqBV,EAAQE,GAAc,IAEpEvL,KAAKkJ,QAAQ9I,eAAe4L,OAAOX,GACnCrL,KAAK3E,eAAewD,MAAMC,UAAS2D,EAAAA,EAAAA,IAA4BzC,KAAKkJ,QAAQ9I,eAAesC,KAAO,GACpG,CACA,wBAAMuJ,GACJ,OAAKjM,KAAKyE,2BAA2BD,aAGhCxE,KAAKkJ,QAAQF,4BAChBhJ,KAAKkJ,QAAQF,2BAA4BkD,EAAAA,EAAAA,KACzClM,KAAK3E,eAAewD,MAAMC,UAASiK,EAAAA,EAAAA,KAA0B,UACvD/I,KAAKkJ,QAAQb,0BAA0B9L,IAExCyD,KAAKkJ,QAAQF,2BAPXmD,QAAQC,OAAO,IAAIrL,MAAM,4DAQpC,CACA,sBAAMsL,GACJ,MAAMC,EAAmBtM,KAAK3E,eAAewD,MAAMU,WAAW+B,gBAAgBiL,gBACxEC,EAAiBxM,KAAKkJ,QAAQF,0BACpChJ,KAAKkJ,QAAQrE,6BAA6BC,EAAAA,GAAiBC,WACvDuH,GACFtM,KAAK3E,eAAewD,MAAMC,UAASyJ,EAAAA,EAAAA,IAAmB,UAChDvI,KAAKkJ,QAAQb,0BAA0B1L,IACpC6P,SACHxM,KAAKkJ,QAAQb,0BAA0B3L,EAEjD,CACA+H,wBAAAA,GACE,OAAOzE,KAAK3E,eAAewD,MAAMU,WAAW2B,0BAA0BG,UAAUC,eAClF,CACAK,cAAAA,GACE,OAAO3B,KAAK3E,eAAewD,MAAMU,WAAW2B,0BAA0BG,UAAUC,gBAAgBH,gBAClG,CACAsL,oBAAAA,CAAqBxL,EAAOyL,GAAmB,GAC7C,MAAO7N,MAAOA,GAASmB,KAAK3E,eAC5B,IAAIsR,EAEFA,EADED,GACSE,EAAAA,EAAAA,GAAM,CAAC,EAAG/N,EAAMU,WAAW2B,0BAA0BG,UAAUC,gBAAgBH,iBAAkBF,IAEjGG,EAAAA,EAAAA,GAAUH,GAEvBpC,EAAMC,UAAS+N,EAAAA,EAAAA,KAA6BlP,EAAAA,EAAAA,GAAWgP,IACzD,EAGF,SAASG,EAAczR,GACrB,OAAO,IAAIyE,EAAsBzE,EACnC,C","sources":["webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/services/haa/humanAgentUtils.js","webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/services/haa/agentStatusMessage.js","webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/services/haa/HumanAgentServiceImpl.js"],"sourcesContent":["import { BusEventType } from \"../../../../types/events/eventBusTypes.js\";\n\nimport { outputItemToLocalItem } from \"../../schema/outputItemToLocalItem.js\";\n\nimport actions from \"../../store/actions.js\";\n\nimport { conditionalSetTimeout } from \"../../utils/browserUtils.js\";\n\nimport { asyncForEach } from \"../../utils/lang/arrayUtils.js\";\n\nimport { deepFreeze } from \"../../utils/lang/objectUtils.js\";\n\nimport { createMessageResponseForItem } from \"../../utils/messageUtils.js\";\n\nimport { getHumanAgentStatusMessageText } from \"./agentStatusMessage.js\";\n\nimport { MessageResponseTypes } from \"../../../../types/messaging/Messages.js\";\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */ function toPair(localMessages, originalMessage) {\n  return {\n    localMessages: localMessages,\n    originalMessage: originalMessage\n  };\n}\n\nasync function createHumanAgentLocalMessage(agentMessageType, serviceManager, responseUserProfile, fireEvents = true) {\n  const text = getHumanAgentStatusMessageText(agentMessageType, responseUserProfile, serviceManager.intl);\n  const result = createHumanAgentLocalMessageForType(agentMessageType);\n  const {originalMessage: originalMessage, localMessage: localMessage} = result;\n  localMessage.item.text = text;\n  if (responseUserProfile) {\n    if (!originalMessage.history) {\n      originalMessage.history = {};\n    }\n    originalMessage.history.response_user_profile = responseUserProfile;\n  }\n  if (fireEvents) {\n    await serviceManager.fire({\n      type: BusEventType.HUMAN_AGENT_PRE_RECEIVE,\n      data: originalMessage\n    });\n  }\n  deepFreeze(originalMessage);\n  if (fireEvents) {\n    await serviceManager.fire({\n      type: BusEventType.HUMAN_AGENT_RECEIVE,\n      data: originalMessage\n    });\n  }\n  return result;\n}\n\nfunction createHumanAgentLocalMessageForType(agentMessageType) {\n  const messageItem = {\n    response_type: MessageResponseTypes.TEXT,\n    agent_message_type: agentMessageType\n  };\n  const originalMessage = createMessageResponseForItem(messageItem);\n  const localMessage = outputItemToLocalItem(messageItem, originalMessage);\n  return {\n    localMessage: localMessage,\n    originalMessage: originalMessage\n  };\n}\n\nfunction createBotReturnMessage(languagePack) {\n  const {agent_botReturned: agent_botReturned} = languagePack;\n  if (!agent_botReturned) {\n    return null;\n  }\n  const {originalMessage: originalMessage, localMessage: localMessage} = createHumanAgentLocalMessageForType(null);\n  localMessage.item.text = agent_botReturned;\n  return {\n    originalMessage: originalMessage,\n    localMessage: localMessage\n  };\n}\n\nasync function addMessages(messagePairs, saveInHistory, fireHistoryEvent, showLiveMessages, serviceManager) {\n  if (showLiveMessages) {\n    await asyncForEach(messagePairs, async ({localMessages: localMessages, originalMessage: originalMessage}) => {\n      await asyncForEach(localMessages, async (localMessage, index) => {\n        await serviceManager.actions.handleUserDefinedResponseItems(localMessage, originalMessage);\n        serviceManager.store.dispatch(actions.addLocalMessageItem(localMessage, originalMessage, index === 0));\n      });\n    });\n  }\n}\n\nasync function addBotReturnMessage(botReturnDelay, wasSuspended, serviceManager) {\n  const botReturn = createBotReturnMessage(serviceManager.store.getState().languagePack);\n  if (botReturn) {\n    const initialRestartCount = serviceManager.restartCount;\n    conditionalSetTimeout(() => {\n      if (initialRestartCount === serviceManager.restartCount) {\n        addMessages([ toPair([ botReturn.localMessage ], botReturn.originalMessage) ], true, false, !wasSuspended, serviceManager);\n      }\n    }, botReturnDelay);\n  }\n}\n\nasync function addHumanAgentEndChatMessage(agentMessageType, responseUserProfile, fireEvents, wasSuspended, serviceManager) {\n  const endChatMessage = await createHumanAgentLocalMessage(agentMessageType, serviceManager, responseUserProfile, fireEvents);\n  await addMessages([ toPair([ endChatMessage.localMessage ], endChatMessage.originalMessage) ], true, false, !wasSuspended, serviceManager);\n}\n\nexport { addBotReturnMessage, addHumanAgentEndChatMessage, addMessages, createHumanAgentLocalMessage, toPair };\n","import { HumanAgentMessageType } from \"../../../../types/messaging/Messages.js\";\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */ function getHumanAgentStatusMessageText(agentMessageType, responseUserProfile, intl) {\n  const name = responseUserProfile?.nickname;\n  let messageKey;\n  switch (agentMessageType) {\n   case HumanAgentMessageType.HUMAN_AGENT_JOINED:\n    {\n      messageKey = name ? \"agent_agentJoinedName\" : \"agent_agentJoinedNoName\";\n      break;\n    }\n\n   case HumanAgentMessageType.RELOAD_WARNING:\n    {\n      messageKey = \"agent_youConnectedWarning\";\n      break;\n    }\n\n   case HumanAgentMessageType.HUMAN_AGENT_LEFT_CHAT:\n    {\n      messageKey = name ? \"agent_agentLeftChat\" : \"agent_agentLeftChatNoName\";\n      break;\n    }\n\n   case HumanAgentMessageType.HUMAN_AGENT_ENDED_CHAT:\n    {\n      messageKey = name ? \"agent_agentEndedChat\" : \"agent_agentEndedChatNoName\";\n      break;\n    }\n\n   case HumanAgentMessageType.TRANSFER_TO_HUMAN_AGENT:\n    {\n      messageKey = name ? \"agent_transferring\" : \"agent_transferringNoName\";\n      break;\n    }\n\n   case HumanAgentMessageType.USER_ENDED_CHAT:\n    {\n      messageKey = \"agent_youEndedChat\";\n      break;\n    }\n\n   case HumanAgentMessageType.CHAT_WAS_ENDED:\n    {\n      messageKey = \"agent_conversationWasEnded\";\n      break;\n    }\n\n   case HumanAgentMessageType.DISCONNECTED:\n    {\n      messageKey = \"agent_disconnected\";\n      break;\n    }\n\n   case HumanAgentMessageType.RECONNECTED:\n    {\n      messageKey = \"agent_reconnected\";\n      break;\n    }\n\n   case HumanAgentMessageType.SHARING_REQUESTED:\n    {\n      messageKey = \"agent_sharingRequested\";\n      break;\n    }\n\n   case HumanAgentMessageType.SHARING_ACCEPTED:\n    {\n      messageKey = \"agent_sharingAccepted\";\n      break;\n    }\n\n   case HumanAgentMessageType.SHARING_DECLINED:\n    {\n      messageKey = \"agent_sharingDeclined\";\n      break;\n    }\n\n   case HumanAgentMessageType.SHARING_CANCELLED:\n    {\n      messageKey = \"agent_sharingCancelled\";\n      break;\n    }\n\n   case HumanAgentMessageType.SHARING_ENDED:\n    {\n      messageKey = \"agent_sharingEnded\";\n      break;\n    }\n\n   default:\n    return \"\";\n  }\n  return messageKey && intl.formatMessage({\n    id: messageKey\n  }, {\n    personName: name\n  });\n}\n\nexport { getHumanAgentStatusMessageText };\n","import cloneDeep from \"lodash-es/cloneDeep.js\";\n\nimport merge from \"lodash-es/merge.js\";\n\nimport inputItemToLocalItem from \"../../schema/inputItemToLocalItem.js\";\n\nimport { createLocalMessageForInlineError, outputItemToLocalItem } from \"../../schema/outputItemToLocalItem.js\";\n\nimport actions from \"../../store/actions.js\";\n\nimport { updateFilesUploadInProgress, setIsConnecting, endChat, setIsScreenSharing, setIsReconnecting, setShowScreenShareRequest, updateCapabilities, setAgentAvailability, setHumanAgentJoined, agentUpdateIsTyping, setHumanAgentLeftChat, setPersistedServiceDeskState } from \"../../store/humanAgentActions.js\";\n\nimport { MessageErrorState } from \"../../../../types/messaging/LocalMessageItem.js\";\n\nimport \"../../utils/constants.js\";\n\nimport { deepFreeze } from \"../../utils/lang/objectUtils.js\";\n\nimport { resolveOrTimeout } from \"../../utils/lang/promiseUtils.js\";\n\nimport { createMessageRequestForText, createMessageRequestForFileUpload, createMessageResponseForText, addDefaultsToMessage } from \"../../utils/messageUtils.js\";\n\nimport { debugLog, consoleError } from \"../../utils/miscUtils.js\";\n\nimport { resolvablePromise } from \"../../utils/resolvablePromise.js\";\n\nimport { ErrorType, ScreenShareState, HumanAgentsOnlineStatus } from \"../../../../types/config/ServiceDeskConfig.js\";\n\nimport { addHumanAgentEndChatMessage, addBotReturnMessage, addMessages, toPair, createHumanAgentLocalMessage } from \"./humanAgentUtils.js\";\n\nimport { HumanAgentMessageType } from \"../../../../types/messaging/Messages.js\";\n\nimport { BusEventType } from \"../../../../types/events/eventBusTypes.js\";\n\nimport { FileStatusValue } from \"../../../../types/instance/apiTypes.js\";\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */ const SEND_TIMEOUT_WARNING_MS = 3e3;\n\nconst SEND_TIMEOUT_ERROR_MS = 2e4;\n\nconst END_CHAT_TIMEOUT_MS = 5e3;\n\nconst AVAILABILITY_TIMEOUT_MS = 5e3;\n\nconst BOT_RETURN_DELAY = 1500;\n\nconst {FROM_USER: FROM_USER, RECONNECTED: RECONNECTED, DISCONNECTED: DISCONNECTED, HUMAN_AGENT_ENDED_CHAT: HUMAN_AGENT_ENDED_CHAT, HUMAN_AGENT_JOINED: HUMAN_AGENT_JOINED, USER_ENDED_CHAT: USER_ENDED_CHAT, CHAT_WAS_ENDED: CHAT_WAS_ENDED, TRANSFER_TO_HUMAN_AGENT: TRANSFER_TO_HUMAN_AGENT, HUMAN_AGENT_LEFT_CHAT: HUMAN_AGENT_LEFT_CHAT, RELOAD_WARNING: RELOAD_WARNING, SHARING_CANCELLED: SHARING_CANCELLED, SHARING_DECLINED: SHARING_DECLINED, SHARING_ACCEPTED: SHARING_ACCEPTED, SHARING_REQUESTED: SHARING_REQUESTED, SHARING_ENDED: SHARING_ENDED} = HumanAgentMessageType;\n\nclass HumanAgentServiceImpl {\n  constructor(serviceManager) {\n    this.chatStarted = false;\n    this.showingDisconnectedError = false;\n    this.isHumanAgentTyping = false;\n    this.uploadingFiles = new Set;\n    this.showLeaveWarning = true;\n    this.serviceManager = serviceManager;\n  }\n  getCustomServiceDeskName() {\n    return this.serviceManager.store.getState().config.public.serviceDeskFactory ? this.serviceDesk.getName?.() : undefined;\n  }\n  async initialize() {\n    if (this.serviceDesk) {\n      throw new Error(\"A service desk has already been created!\");\n    }\n    const {store: store, instance: instance} = this.serviceManager;\n    const state = store.getState();\n    const {config: config, persistedToBrowserStorage: persistedToBrowserStorage} = state;\n    const serviceDeskState = cloneDeep(persistedToBrowserStorage.chatState.humanAgentState.serviceDeskState);\n    this.serviceDeskCallback = new ServiceDeskCallbackImpl(this.serviceManager, this);\n    if (config.public.serviceDeskFactory) {\n      const parameters = {\n        callback: this.serviceDeskCallback,\n        instance: instance,\n        persistedState: serviceDeskState\n      };\n      this.serviceDesk = await config.public.serviceDeskFactory(parameters);\n      validateCustomServiceDesk(this.serviceDesk);\n      debugLog(\"Initializing a custom service desk\");\n    }\n    this.showLeaveWarning = !this.serviceDesk?.reconnect;\n  }\n  async startChat(localConnectMessage, originalMessage) {\n    if (!this.serviceDesk) {\n      throw new Error(\"A service desk has not been configured.\");\n    }\n    if (this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState.isSuspended) {\n      await this.endChat(true, true, false);\n    }\n    if (this.chatStarted) {\n      throw new Error(\"A chat is already running. A call to endChat must be made before a new chat can start.\");\n    }\n    const {serviceManager: serviceManager} = this;\n    try {\n      this.chatStarted = true;\n      this.isHumanAgentTyping = false;\n      this.uploadingFiles.clear();\n      this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.uploadingFiles.size > 0));\n      const event = {\n        type: BusEventType.HUMAN_AGENT_PRE_START_CHAT,\n        message: originalMessage\n      };\n      await serviceManager.fire(event);\n      if (event.cancelStartChat) {\n        this.chatStarted = false;\n        await this.fireEndChat(false, true);\n        serviceManager.store.dispatch(setIsConnecting(false, null));\n        return;\n      }\n      const agentJoinTimeout = serviceManager.store.getState().config.public.serviceDesk?.agentJoinTimeoutSeconds;\n      if (agentJoinTimeout) {\n        this.waitingForHumanAgentJoinedTimer = setTimeout(() => this.handleHumanAgentJoinedTimeout(), agentJoinTimeout * 1e3);\n      }\n      serviceManager.store.dispatch(setIsConnecting(true, localConnectMessage.ui_state.id));\n      await this.serviceDesk.startChat(originalMessage, {\n        preStartChatPayload: event.preStartChatPayload\n      });\n    } catch (error) {\n      consoleError(\"[startChat] An error with the service desk occurred.\", error);\n      if (this.serviceDeskCallback) {\n        await this.serviceDeskCallback.setErrorStatus({\n          type: ErrorType.CONNECTING,\n          logInfo: error\n        });\n      }\n      serviceManager.store.dispatch(setIsConnecting(false, null));\n      this.chatStarted = false;\n      this.cancelHumanAgentJoinedTimer();\n      throw error;\n    }\n  }\n  async firePreEndChat(endedByHumanAgent) {\n    const event = {\n      type: BusEventType.HUMAN_AGENT_PRE_END_CHAT,\n      endedByHumanAgent: endedByHumanAgent,\n      preEndChatPayload: null,\n      cancelEndChat: false\n    };\n    await this.serviceManager.fire(event);\n    return event;\n  }\n  async fireEndChat(endedByHumanAgent, requestCancelled) {\n    await this.serviceManager.fire({\n      type: BusEventType.HUMAN_AGENT_END_CHAT,\n      endedByHumanAgent: endedByHumanAgent,\n      requestCancelled: requestCancelled\n    });\n  }\n  async endChat(endedByUser, showHumanAgentLeftMessage = true, showBotReturnMessage = true) {\n    if (!this.chatStarted || !this.serviceDesk) {\n      return;\n    }\n    const {isConnected: isConnected} = this.persistedHumanAgentState();\n    let event;\n    if (isConnected) {\n      event = await this.firePreEndChat(false);\n      if (event.cancelEndChat) {\n        return;\n      }\n    }\n    const endMessageType = endedByUser ? USER_ENDED_CHAT : CHAT_WAS_ENDED;\n    await this.doEndChat(false, event?.preEndChatPayload, showHumanAgentLeftMessage, showBotReturnMessage, endMessageType);\n  }\n  async doEndChat(endedByHumanAgent, preEndChatPayload, showHumanAgentLeftMessage, showBotReturnMessage, agentEndChatMessageType) {\n    const {isConnected: isConnected} = this.persistedHumanAgentState();\n    const wasSuspended = this.isSuspended();\n    this.cancelHumanAgentJoinedTimer();\n    this.closeScreenShareRequestModal(ScreenShareState.CANCELLED);\n    try {\n      await resolveOrTimeout(this.serviceDesk.endChat({\n        endedByHumanAgent: endedByHumanAgent,\n        preEndChatPayload: preEndChatPayload\n      }), END_CHAT_TIMEOUT_MS);\n    } catch (error) {\n      consoleError(\"[doEndChat] An error with the service desk occurred.\", error);\n    }\n    if (isConnected && showHumanAgentLeftMessage) {\n      const {responseUserProfile: responseUserProfile} = this.persistedHumanAgentState();\n      await addHumanAgentEndChatMessage(agentEndChatMessageType, responseUserProfile, true, wasSuspended, this.serviceManager);\n    }\n    this.chatStarted = false;\n    this.isHumanAgentTyping = false;\n    this.serviceManager.store.dispatch(endChat());\n    await this.fireEndChat(endedByHumanAgent, !isConnected);\n    if (isConnected && showBotReturnMessage) {\n      await addBotReturnMessage(BOT_RETURN_DELAY, wasSuspended, this.serviceManager);\n    }\n  }\n  async sendMessageToAgent(text, uploads) {\n    if (!this.serviceDesk || !this.chatStarted) {\n      return;\n    }\n    const {serviceManager: serviceManager} = this;\n    deepFreeze(uploads);\n    const originalMessage = createMessageRequestForText(text);\n    originalMessage.input.agent_message_type = FROM_USER;\n    await serviceManager.fire({\n      type: BusEventType.HUMAN_AGENT_PRE_SEND,\n      data: originalMessage,\n      files: uploads\n    });\n    const textMessage = inputItemToLocalItem(originalMessage, originalMessage.input.text);\n    const localMessageID = textMessage.ui_state.id;\n    const pairs = [];\n    if (textMessage.item.text) {\n      pairs.push(toPair([ textMessage ], originalMessage));\n    }\n    uploads.forEach(upload => {\n      const uploadOriginalMessage = createMessageRequestForFileUpload(upload);\n      const uploadLocalMessage = inputItemToLocalItem(uploadOriginalMessage, uploadOriginalMessage.input.text, upload.id);\n      pairs.push(toPair([ uploadLocalMessage ], uploadOriginalMessage));\n      this.uploadingFiles.add(upload.id);\n    });\n    this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.uploadingFiles.size > 0));\n    await addMessages(pairs, true, true, !this.isSuspended(), serviceManager);\n    let messageSucceeded = false;\n    let messageFailed = false;\n    setTimeout(() => {\n      if (!messageSucceeded && !messageFailed) {\n        this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.RETRYING);\n      }\n    }, SEND_TIMEOUT_WARNING_MS);\n    setTimeout(() => {\n      if (!messageSucceeded) {\n        this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.FAILED);\n      }\n    }, SEND_TIMEOUT_ERROR_MS);\n    const additionalData = {\n      filesToUpload: uploads\n    };\n    try {\n      await this.serviceDesk.sendMessageToAgent(originalMessage, localMessageID, additionalData);\n      messageSucceeded = true;\n      this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.NONE);\n      await serviceManager.fire({\n        type: BusEventType.HUMAN_AGENT_SEND,\n        data: originalMessage,\n        files: uploads\n      });\n    } catch (error) {\n      messageFailed = true;\n      consoleError(\"[sendMessageToAgent] An error with the service desk occurred.\", error);\n      this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.FAILED);\n    }\n  }\n  filesSelectedForUpload(uploads) {\n    if (!this.serviceDesk || !this.chatStarted) {\n      return;\n    }\n    try {\n      this.serviceDesk.filesSelectedForUpload?.(uploads);\n    } catch (error) {\n      consoleError(\"[userReadMessages] An error with the service desk occurred.\", error);\n    }\n  }\n  async userReadMessages() {\n    if (!this.serviceDesk || !this.chatStarted) {\n      return;\n    }\n    try {\n      await this.serviceDesk.userReadMessages();\n    } catch (error) {\n      consoleError(\"[userReadMessages] An error with the service desk occurred.\", error);\n    }\n  }\n  async checkAreAnyHumanAgentsOnline(connectMessage) {\n    let resultValue;\n    const initialRestartCount = this.serviceManager.restartCount;\n    if (!this.serviceDesk?.areAnyAgentsOnline) {\n      resultValue = HumanAgentsOnlineStatus.UNKNOWN;\n    } else {\n      try {\n        const timeoutSeconds = this.serviceManager.store.getState().config.public.serviceDesk?.availabilityTimeoutSeconds;\n        const timeout = timeoutSeconds ? timeoutSeconds * 1e3 : AVAILABILITY_TIMEOUT_MS;\n        const result = await resolveOrTimeout(this.serviceDesk.areAnyAgentsOnline(connectMessage), timeout);\n        if (result === true) {\n          resultValue = HumanAgentsOnlineStatus.ONLINE;\n        } else if (result === false) {\n          resultValue = HumanAgentsOnlineStatus.OFFLINE;\n        } else {\n          resultValue = HumanAgentsOnlineStatus.UNKNOWN;\n        }\n      } catch (error) {\n        consoleError(\"Error attempting to get agent availability\", error);\n        resultValue = HumanAgentsOnlineStatus.OFFLINE;\n      }\n    }\n    if (initialRestartCount === this.serviceManager.restartCount) {\n      this.serviceManager.fire({\n        type: BusEventType.HUMAN_AGENT_ARE_ANY_AGENTS_ONLINE,\n        areAnyAgentsOnline: resultValue\n      });\n    }\n    return resultValue;\n  }\n  async userTyping(isTyping) {\n    if (!this.serviceDesk || !this.chatStarted) {\n      return;\n    }\n    try {\n      await (this.serviceDesk.userTyping?.(isTyping));\n    } catch (error) {\n      consoleError(\"[userTyping] An error with the service desk occurred.\", error);\n    }\n  }\n  setMessageErrorState(messageID, errorState) {\n    this.serviceManager.store.dispatch(actions.setMessageErrorState(messageID, errorState));\n  }\n  async handleHumanAgentJoinedTimeout() {\n    const message = this.serviceManager.store.getState().languagePack.errors_noHumanAgentsJoined;\n    const {originalMessage: originalMessage, localMessage: localMessage} = createLocalMessageForInlineError(message);\n    await addMessages([ toPair([ localMessage ], originalMessage) ], true, false, !this.isSuspended(), this.serviceManager);\n    this.endChat(false);\n  }\n  cancelHumanAgentJoinedTimer() {\n    if (this.waitingForHumanAgentJoinedTimer) {\n      clearTimeout(this.waitingForHumanAgentJoinedTimer);\n      this.waitingForHumanAgentJoinedTimer = null;\n    }\n  }\n  async screenShareUpdateRequestState(state) {\n    if (!this.persistedHumanAgentState().isConnected) {\n      return;\n    }\n    this.closeScreenShareRequestModal(state);\n    let agentMessageType;\n    switch (state) {\n     case ScreenShareState.ACCEPTED:\n      agentMessageType = SHARING_ACCEPTED;\n      break;\n\n     case ScreenShareState.DECLINED:\n      agentMessageType = SHARING_DECLINED;\n      break;\n\n     case ScreenShareState.CANCELLED:\n      agentMessageType = SHARING_CANCELLED;\n      break;\n\n     case ScreenShareState.ENDED:\n      agentMessageType = SHARING_ENDED;\n      break;\n\n     default:\n      return;\n    }\n    await this.addHumanAgentLocalMessage(agentMessageType);\n  }\n  async screenShareStop() {\n    this.serviceManager.store.dispatch(setIsScreenSharing(false));\n    await this.addHumanAgentLocalMessage(SHARING_ENDED);\n    await (this.serviceDesk?.screenShareStop?.());\n  }\n  async handleHydration(allowReconnect, allowEndChatMessages) {\n    const {store: store} = this.serviceManager;\n    let didReconnect = false;\n    const {isConnected: isConnected} = this.persistedHumanAgentState();\n    if (isConnected) {\n      this.chatStarted = true;\n      if (allowReconnect && this.serviceDesk?.reconnect) {\n        try {\n          store.dispatch(setIsReconnecting(true));\n          setTimeout(this.serviceManager.appWindow.requestFocus);\n          didReconnect = await this.serviceDesk.reconnect();\n        } catch (error) {\n          consoleError(`Error while trying to reconnect to an agent.`, error);\n        }\n      }\n      store.dispatch(setIsReconnecting(false));\n      if (!this.persistedHumanAgentState().isConnected) {\n        this.chatStarted = false;\n        return;\n      }\n      setTimeout(this.serviceManager.appWindow.requestFocus);\n      if (!didReconnect) {\n        this.chatStarted = false;\n        const wasSuspended = this.isSuspended();\n        store.dispatch(endChat());\n        if (allowEndChatMessages) {\n          const {responseUserProfile: responseUserProfile} = this.persistedHumanAgentState();\n          await addHumanAgentEndChatMessage(HumanAgentMessageType.CHAT_WAS_ENDED, responseUserProfile, false, wasSuspended, this.serviceManager);\n          await addBotReturnMessage(0, wasSuspended, this.serviceManager);\n        }\n      } else {\n        this.showLeaveWarning = false;\n      }\n    }\n  }\n  closeScreenShareRequestModal(state) {\n    this.serviceManager.store.dispatch(setShowScreenShareRequest(false));\n    if (this.screenShareRequestPromise) {\n      this.screenShareRequestPromise.doResolve(state);\n      this.screenShareRequestPromise = null;\n    }\n    this.serviceManager.store.dispatch(setIsScreenSharing(state === ScreenShareState.ACCEPTED));\n  }\n  async addHumanAgentLocalMessage(agentMessageType, responseUserProfile, fireEvents = true, saveInHistory = true) {\n    if (!responseUserProfile) {\n      responseUserProfile = this.persistedHumanAgentState().responseUserProfile;\n    }\n    const {localMessage: localMessage, originalMessage: originalMessage} = await createHumanAgentLocalMessage(agentMessageType, this.serviceManager, responseUserProfile, fireEvents);\n    await addMessages([ toPair([ localMessage ], originalMessage) ], saveInHistory, false, !this.isSuspended(), this.serviceManager);\n  }\n  persistedHumanAgentState() {\n    return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState;\n  }\n  isSuspended() {\n    return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState.isSuspended;\n  }\n}\n\nclass ServiceDeskCallbackImpl {\n  constructor(serviceManager, service) {\n    this.serviceManager = serviceManager;\n    this.service = service;\n  }\n  updateCapabilities(capabilities) {\n    this.serviceManager.store.dispatch(updateCapabilities(cloneDeep(capabilities)));\n  }\n  async updateAgentAvailability(availability) {\n    if (!this.service.chatStarted) {\n      return;\n    }\n    this.serviceManager.store.dispatch(setAgentAvailability(availability));\n  }\n  async agentJoined(profile) {\n    if (!this.service.chatStarted) {\n      return;\n    }\n    this.service.cancelHumanAgentJoinedTimer();\n    this.serviceManager.store.dispatch(setHumanAgentJoined(profile));\n    await this.service.addHumanAgentLocalMessage(HUMAN_AGENT_JOINED, profile);\n    if (this.service.showLeaveWarning) {\n      await this.service.addHumanAgentLocalMessage(RELOAD_WARNING, null, false, false);\n      this.service.showLeaveWarning = false;\n    }\n  }\n  async agentReadMessages() {\n    if (!this.service.chatStarted) {\n      return;\n    }\n    debugLog(\"[ServiceDeskCallbackImpl] agentReadMessages\");\n  }\n  async agentTyping(isTyping) {\n    if (this.persistedHumanAgentState().isConnected && isTyping !== this.service.isHumanAgentTyping) {\n      this.serviceManager.store.dispatch(agentUpdateIsTyping(isTyping));\n      this.service.isHumanAgentTyping = isTyping;\n    }\n  }\n  async sendMessageToUser(message, agentID) {\n    if (!this.service.chatStarted || !message) {\n      return;\n    }\n    const messageResponse = typeof message === \"string\" ? createMessageResponseForText(message) : message;\n    addDefaultsToMessage(messageResponse);\n    if (messageResponse.output?.generic?.length) {\n      messageResponse.output.generic.forEach(messageItem => {\n        if (!messageItem.agent_message_type) {\n          messageItem.agent_message_type = HumanAgentMessageType.FROM_HUMAN_AGENT;\n        }\n      });\n    }\n    const {serviceManager: serviceManager} = this;\n    let responseUserProfile;\n    if (agentID === undefined) {\n      responseUserProfile = this.persistedHumanAgentState().responseUserProfile;\n    } else {\n      responseUserProfile = this.persistedHumanAgentState().responseUserProfiles[agentID];\n      if (!responseUserProfile) {\n        responseUserProfile = this.persistedHumanAgentState().responseUserProfile;\n        if (responseUserProfile) {\n          consoleError(`Got agent ID ${agentID} but no agent with that ID joined the conversation. Using the current agent instead.`);\n        }\n      }\n    }\n    await serviceManager.fire({\n      type: BusEventType.HUMAN_AGENT_PRE_RECEIVE,\n      data: messageResponse,\n      responseUserProfile: responseUserProfile\n    });\n    messageResponse.history.response_user_profile = responseUserProfile;\n    const localMessages = messageResponse.output.generic.map(item => outputItemToLocalItem(item, messageResponse));\n    await addMessages([ toPair(localMessages, messageResponse) ], true, true, !this.service.isSuspended(), this.serviceManager);\n    await serviceManager.fire({\n      type: BusEventType.HUMAN_AGENT_RECEIVE,\n      data: messageResponse,\n      responseUserProfile: responseUserProfile\n    });\n  }\n  async beginTransferToAnotherAgent(profile) {\n    if (!this.service.chatStarted) {\n      return;\n    }\n    if (profile) {\n      this.serviceManager.store.dispatch(setHumanAgentJoined(profile));\n    }\n    await this.service.addHumanAgentLocalMessage(TRANSFER_TO_HUMAN_AGENT, profile);\n  }\n  async agentLeftChat() {\n    if (!this.service.chatStarted) {\n      return;\n    }\n    await this.service.addHumanAgentLocalMessage(HUMAN_AGENT_LEFT_CHAT);\n    this.service.isHumanAgentTyping = false;\n    this.serviceManager.store.dispatch(setHumanAgentLeftChat());\n  }\n  async agentEndedChat() {\n    if (!this.service.chatStarted) {\n      return;\n    }\n    const event = await this.service.firePreEndChat(true);\n    if (event.cancelEndChat) {\n      return;\n    }\n    await this.service.doEndChat(true, event.preEndChatPayload, true, true, HUMAN_AGENT_ENDED_CHAT);\n  }\n  async setErrorStatus(errorInfo) {\n    if (!this.service.chatStarted) {\n      return;\n    }\n    const {type: type, logInfo: logInfo} = errorInfo;\n    const {store: store} = this.serviceManager;\n    const {isConnecting: isConnecting} = store.getState().humanAgentState;\n    if (logInfo) {\n      consoleError(`An error occurred in the service desk (type=${type})`, logInfo);\n    }\n    if (isConnecting && errorInfo.type === ErrorType.DISCONNECTED && errorInfo.isDisconnected) {\n      errorInfo = {\n        type: ErrorType.CONNECTING\n      };\n    }\n    switch (errorInfo.type) {\n     case ErrorType.DISCONNECTED:\n      {\n        if (errorInfo.isDisconnected) {\n          this.service.showingDisconnectedError = true;\n          await this.service.addHumanAgentLocalMessage(DISCONNECTED, null, true, false);\n          store.dispatch(actions.updateInputState({\n            isReadonly: true\n          }, true));\n        } else if (this.service.showingDisconnectedError) {\n          this.service.showingDisconnectedError = false;\n          await this.service.addHumanAgentLocalMessage(RECONNECTED, null, true, false);\n          store.dispatch(actions.updateInputState({\n            isReadonly: false\n          }, true));\n        }\n        break;\n      }\n\n     case ErrorType.CONNECTING:\n      {\n        const {languagePack: languagePack} = this.serviceManager.store.getState();\n        const message = errorInfo.messageToUser || languagePack.errors_connectingToHumanAgent;\n        const {originalMessage: originalMessage, localMessage: localMessage} = createLocalMessageForInlineError(message);\n        await addMessages([ toPair([ localMessage ], originalMessage) ], true, false, !this.service.isSuspended(), this.serviceManager);\n        this.serviceManager.store.dispatch(setIsConnecting(false, null));\n        this.service.chatStarted = false;\n        this.service.cancelHumanAgentJoinedTimer();\n        await this.service.fireEndChat(false, isConnecting);\n        break;\n      }\n\n     case ErrorType.USER_MESSAGE:\n      {\n        this.service.setMessageErrorState(errorInfo.messageID, MessageErrorState.FAILED);\n        break;\n      }\n    }\n  }\n  async setFileUploadStatus(fileID, isError, errorMessage) {\n    const {store: store} = this.serviceManager;\n    const uploadMessage = store.getState().allMessagesByID[fileID];\n    if (uploadMessage) {\n      ({\n        history: {\n          file_upload_status: FileStatusValue.COMPLETE\n        }\n      });\n      if (isError) {\n        store.dispatch(actions.setMessageHistoryProperty(fileID, \"file_upload_status\", FileStatusValue.COMPLETE));\n        store.dispatch(actions.setMessageHistoryProperty(fileID, \"error_state\", MessageErrorState.FAILED));\n        MessageErrorState.FAILED;\n        if (errorMessage) {\n          const {originalMessage: originalMessage, localMessage: localMessage} = createLocalMessageForInlineError(errorMessage);\n          localMessage.item.agent_message_type = HumanAgentMessageType.INLINE_ERROR;\n          await addMessages([ toPair([ localMessage ], originalMessage) ], true, true, !this.service.isSuspended(), this.serviceManager);\n        }\n      } else {\n        store.dispatch(actions.setMessageHistoryProperty(fileID, \"file_upload_status\", FileStatusValue.SUCCESS));\n        store.dispatch(actions.announceMessage({\n          messageID: \"fileSharing_ariaAnnounceSuccess\"\n        }));\n      }\n    } else if (isError) {\n      store.dispatch(actions.fileUploadInputError(fileID, errorMessage, true));\n    }\n    this.service.uploadingFiles.delete(fileID);\n    this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.service.uploadingFiles.size > 0));\n  }\n  async screenShareRequest() {\n    if (!this.persistedHumanAgentState().isConnected) {\n      return Promise.reject(new Error(\"Cannot request screen sharing if no chat is in progress.\"));\n    }\n    if (!this.service.screenShareRequestPromise) {\n      this.service.screenShareRequestPromise = resolvablePromise();\n      this.serviceManager.store.dispatch(setShowScreenShareRequest(true));\n      await this.service.addHumanAgentLocalMessage(SHARING_REQUESTED);\n    }\n    return this.service.screenShareRequestPromise;\n  }\n  async screenShareEnded() {\n    const wasScreenSharing = this.serviceManager.store.getState().humanAgentState.isScreenSharing;\n    const requestPending = this.service.screenShareRequestPromise;\n    this.service.closeScreenShareRequestModal(ScreenShareState.CANCELLED);\n    if (wasScreenSharing) {\n      this.serviceManager.store.dispatch(setIsScreenSharing(false));\n      await this.service.addHumanAgentLocalMessage(SHARING_ENDED);\n    } else if (requestPending) {\n      await this.service.addHumanAgentLocalMessage(SHARING_CANCELLED);\n    }\n  }\n  persistedHumanAgentState() {\n    return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState;\n  }\n  persistedState() {\n    return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState.serviceDeskState;\n  }\n  updatePersistedState(state, mergeWithCurrent = true) {\n    const {store: store} = this.serviceManager;\n    let newState;\n    if (mergeWithCurrent) {\n      newState = merge({}, store.getState().persistedToBrowserStorage.chatState.humanAgentState.serviceDeskState, state);\n    } else {\n      newState = cloneDeep(state);\n    }\n    store.dispatch(setPersistedServiceDeskState(deepFreeze(newState)));\n  }\n}\n\nfunction createService(serviceManager) {\n  return new HumanAgentServiceImpl(serviceManager);\n}\n\nfunction validateCustomServiceDesk(serviceDesk) {\n  if (!serviceDesk) {\n    consoleError(\"The custom service desk does not appear to be valid. No service desk was provided.\", serviceDesk);\n  } else if (typeof serviceDesk !== \"object\") {\n    consoleError(`The custom service desk does not appear to be valid. The type should be \"object\" but is \"${typeof serviceDesk}\"`, serviceDesk);\n  } else {\n    const propertyNames = [ \"startChat\", \"endChat\", \"sendMessageToAgent\" ];\n    propertyNames.forEach(propertyName => {\n      const value = serviceDesk[propertyName];\n      if (typeof value !== \"function\") {\n        consoleError(`The custom service desk does not appear to be valid. The type of property \"${propertyName}\"should be \"function\" but is \"${typeof value}\"`, value, serviceDesk);\n      }\n    });\n    const name = serviceDesk.getName?.();\n    if (!name) {\n      throw Error(\"The custom service desk does not have a name.\");\n    }\n    if (name && (typeof name !== \"string\" || name.length > 40)) {\n      throw new Error(`The custom service desk name \"${name}\" is not valid.`);\n    }\n  }\n}\n\nexport { HumanAgentServiceImpl, createService, validateCustomServiceDesk };\n"],"names":["toPair","localMessages","originalMessage","async","createHumanAgentLocalMessage","agentMessageType","serviceManager","responseUserProfile","fireEvents","text","intl","name","nickname","messageKey","HumanAgentMessageType","HUMAN_AGENT_JOINED","RELOAD_WARNING","HUMAN_AGENT_LEFT_CHAT","HUMAN_AGENT_ENDED_CHAT","TRANSFER_TO_HUMAN_AGENT","USER_ENDED_CHAT","CHAT_WAS_ENDED","DISCONNECTED","RECONNECTED","SHARING_REQUESTED","SHARING_ACCEPTED","SHARING_DECLINED","SHARING_CANCELLED","SHARING_ENDED","formatMessage","id","personName","getHumanAgentStatusMessageText","result","createHumanAgentLocalMessageForType","localMessage","item","history","response_user_profile","fire","type","BusEventType","HUMAN_AGENT_PRE_RECEIVE","data","deepFreeze","HUMAN_AGENT_RECEIVE","messageItem","response_type","MessageResponseTypes","TEXT","agent_message_type","createMessageResponseForItem","outputItemToLocalItem","addMessages","messagePairs","saveInHistory","fireHistoryEvent","showLiveMessages","asyncForEach","index","actions","handleUserDefinedResponseItems","store","dispatch","addLocalMessageItem","addBotReturnMessage","botReturnDelay","wasSuspended","botReturn","languagePack","agent_botReturned","createBotReturnMessage","getState","initialRestartCount","restartCount","conditionalSetTimeout","addHumanAgentEndChatMessage","endChatMessage","FROM_USER","HumanAgentServiceImpl","constructor","this","chatStarted","showingDisconnectedError","isHumanAgentTyping","uploadingFiles","Set","showLeaveWarning","getCustomServiceDeskName","config","public","serviceDeskFactory","serviceDesk","getName","undefined","initialize","Error","instance","state","persistedToBrowserStorage","serviceDeskState","cloneDeep","chatState","humanAgentState","serviceDeskCallback","ServiceDeskCallbackImpl","parameters","callback","persistedState","consoleError","forEach","propertyName","value","length","validateCustomServiceDesk","debugLog","reconnect","startChat","localConnectMessage","isSuspended","endChat","clear","updateFilesUploadInProgress","size","event","HUMAN_AGENT_PRE_START_CHAT","message","cancelStartChat","fireEndChat","setIsConnecting","agentJoinTimeout","agentJoinTimeoutSeconds","waitingForHumanAgentJoinedTimer","setTimeout","handleHumanAgentJoinedTimeout","ui_state","preStartChatPayload","error","setErrorStatus","ErrorType","CONNECTING","logInfo","cancelHumanAgentJoinedTimer","firePreEndChat","endedByHumanAgent","HUMAN_AGENT_PRE_END_CHAT","preEndChatPayload","cancelEndChat","requestCancelled","HUMAN_AGENT_END_CHAT","endedByUser","showHumanAgentLeftMessage","showBotReturnMessage","isConnected","persistedHumanAgentState","endMessageType","doEndChat","agentEndChatMessageType","closeScreenShareRequestModal","ScreenShareState","CANCELLED","resolveOrTimeout","sendMessageToAgent","uploads","createMessageRequestForText","input","HUMAN_AGENT_PRE_SEND","files","textMessage","inputItemToLocalItem","localMessageID","pairs","push","upload","uploadOriginalMessage","createMessageRequestForFileUpload","uploadLocalMessage","add","messageSucceeded","messageFailed","setMessageErrorState","fullMessageID","MessageErrorState","RETRYING","FAILED","additionalData","filesToUpload","NONE","HUMAN_AGENT_SEND","filesSelectedForUpload","userReadMessages","checkAreAnyHumanAgentsOnline","connectMessage","resultValue","areAnyAgentsOnline","timeoutSeconds","availabilityTimeoutSeconds","timeout","HumanAgentsOnlineStatus","ONLINE","OFFLINE","UNKNOWN","HUMAN_AGENT_ARE_ANY_AGENTS_ONLINE","userTyping","isTyping","messageID","errorState","errors_noHumanAgentsJoined","createLocalMessageForInlineError","clearTimeout","screenShareUpdateRequestState","ACCEPTED","DECLINED","ENDED","addHumanAgentLocalMessage","screenShareStop","setIsScreenSharing","handleHydration","allowReconnect","allowEndChatMessages","didReconnect","setIsReconnecting","appWindow","requestFocus","setShowScreenShareRequest","screenShareRequestPromise","doResolve","service","updateCapabilities","capabilities","updateAgentAvailability","availability","setAgentAvailability","agentJoined","profile","setHumanAgentJoined","agentReadMessages","agentTyping","agentUpdateIsTyping","sendMessageToUser","agentID","messageResponse","createMessageResponseForText","addDefaultsToMessage","output","generic","FROM_HUMAN_AGENT","responseUserProfiles","map","beginTransferToAnotherAgent","agentLeftChat","setHumanAgentLeftChat","agentEndedChat","errorInfo","isConnecting","isDisconnected","updateInputState","isReadonly","messageToUser","errors_connectingToHumanAgent","USER_MESSAGE","setFileUploadStatus","fileID","isError","errorMessage","allMessagesByID","FileStatusValue","COMPLETE","setMessageHistoryProperty","INLINE_ERROR","SUCCESS","announceMessage","fileUploadInputError","delete","screenShareRequest","resolvablePromise","Promise","reject","screenShareEnded","wasScreenSharing","isScreenSharing","requestPending","updatePersistedState","mergeWithCurrent","newState","merge","setPersistedServiceDeskState","createService"],"sourceRoot":""}