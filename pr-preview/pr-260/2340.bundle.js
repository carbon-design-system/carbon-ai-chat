/*! For license information please see 2340.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunk_carbon_ai_chat_examples_demo=self.webpackChunk_carbon_ai_chat_examples_demo||[]).push([[2340],{2340:function(e,t,s){s.d(t,{createService:function(){return W}});var a=s(8690),i=s(1122),r=s(9499),n=s(1120),c=s(1748),o=s(8854),h=s(3092),g=s(9280),d=s(9080),u=s(7391),l=s(2870),p=s(5041),A=s(8625),E=s(5505),S=s(5230),v=s(948),y=s(9633);function M(e,t){return{localMessages:e,originalMessage:t}}async function _(e,t,s,a=!0){const i=function(e,t,s){const a=t?.nickname;let i;switch(e){case y.iR.HUMAN_AGENT_JOINED:i=a?"agent_agentJoinedName":"agent_agentJoinedNoName";break;case y.iR.RELOAD_WARNING:i="agent_youConnectedWarning";break;case y.iR.HUMAN_AGENT_LEFT_CHAT:i=a?"agent_agentLeftChat":"agent_agentLeftChatNoName";break;case y.iR.HUMAN_AGENT_ENDED_CHAT:i=a?"agent_agentEndedChat":"agent_agentEndedChatNoName";break;case y.iR.TRANSFER_TO_HUMAN_AGENT:i=a?"agent_transferring":"agent_transferringNoName";break;case y.iR.USER_ENDED_CHAT:i="agent_youEndedChat";break;case y.iR.CHAT_WAS_ENDED:i="agent_conversationWasEnded";break;case y.iR.DISCONNECTED:i="agent_disconnected";break;case y.iR.RECONNECTED:i="agent_reconnected";break;case y.iR.SHARING_REQUESTED:i="agent_sharingRequested";break;case y.iR.SHARING_ACCEPTED:i="agent_sharingAccepted";break;case y.iR.SHARING_DECLINED:i="agent_sharingDeclined";break;case y.iR.SHARING_CANCELLED:i="agent_sharingCancelled";break;case y.iR.SHARING_ENDED:i="agent_sharingEnded";break;default:return""}return i&&s.formatMessage({id:i},{personName:a})}(e,s,t.intl),r=N(e),{originalMessage:n,localMessage:c}=r;return c.item.text=i,s&&(n.history||(n.history={}),n.history.response_user_profile=s),a&&await t.fire({type:E.xp.HUMAN_AGENT_PRE_RECEIVE,data:n}),(0,g.o)(n),a&&await t.fire({type:E.xp.HUMAN_AGENT_RECEIVE,data:n}),r}function N(e){const t={response_type:y.sP.TEXT,agent_message_type:e},s=(0,u.jv)(t);return{localMessage:(0,n.CL)(t,s),originalMessage:s}}async function m(e,t,s,a,i){a&&await(0,v.PQ)(e,async({localMessages:e,originalMessage:t})=>{await(0,v.PQ)(e,async(e,s)=>{await i.actions.handleUserDefinedResponseItems(e,t),i.store.dispatch(c.Ay.addLocalMessageItem(e,t,0===s))})})}async function C(e,t,s){const a=function(e){const{agent_botReturned:t}=e;if(!t)return null;const{originalMessage:s,localMessage:a}=N(null);return a.item.text=t,{originalMessage:s,localMessage:a}}(s.store.getState().languagePack);if(a){const i=s.restartCount;(0,S.Ah)(()=>{i===s.restartCount&&m([M([a.localMessage],a.originalMessage)],0,0,!t,s)},e)}}async function f(e,t,s,a,i){const r=await _(e,i,t,s);await m([M([r.localMessage],r.originalMessage)],0,0,!a,i)}var T=s(6895);const{FROM_USER:D,RECONNECTED:w,DISCONNECTED:H,HUMAN_AGENT_ENDED_CHAT:R,HUMAN_AGENT_JOINED:k,USER_ENDED_CHAT:I,CHAT_WAS_ENDED:L,TRANSFER_TO_HUMAN_AGENT:b,HUMAN_AGENT_LEFT_CHAT:P,RELOAD_WARNING:U,SHARING_CANCELLED:F,SHARING_DECLINED:G,SHARING_ACCEPTED:O,SHARING_REQUESTED:J,SHARING_ENDED:q}=y.iR;class B{constructor(e){this.chatStarted=!1,this.showingDisconnectedError=!1,this.isHumanAgentTyping=!1,this.uploadingFiles=new Set,this.showLeaveWarning=!0,this.serviceManager=e}getCustomServiceDeskName(){return this.serviceManager.store.getState().config.public.serviceDeskFactory?this.serviceDesk.getName?.():void 0}async initialize(){if(this.serviceDesk)throw new Error("A service desk has already been created!");const{store:e,instance:t}=this.serviceManager,s=e.getState(),{config:i,persistedToBrowserStorage:r}=s,n=(0,a.A)(r.chatState.humanAgentState.serviceDeskState);if(this.serviceDeskCallback=new x(this.serviceManager,this),i.public.serviceDeskFactory){const e={callback:this.serviceDeskCallback,instance:t,persistedState:n};this.serviceDesk=await i.public.serviceDeskFactory(e),function(e){if(e)if("object"!=typeof e)(0,l.yA)(`The custom service desk does not appear to be valid. The type should be "object" but is "${typeof e}"`,e);else{["startChat","endChat","sendMessageToAgent"].forEach(t=>{const s=e[t];"function"!=typeof s&&(0,l.yA)(`The custom service desk does not appear to be valid. The type of property "${t}"should be "function" but is "${typeof s}"`,s,e)});const t=e.getName?.();if(!t)throw Error("The custom service desk does not have a name.");if(t&&("string"!=typeof t||t.length>40))throw new Error(`The custom service desk name "${t}" is not valid.`)}else(0,l.yA)("The custom service desk does not appear to be valid. No service desk was provided.",e)}(this.serviceDesk),(0,l.cY)("Initializing a custom service desk")}this.showLeaveWarning=!this.serviceDesk?.reconnect}async startChat(e,t){if(!this.serviceDesk)throw new Error("A service desk has not been configured.");if(this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState.isSuspended&&await this.endChat(!0,!0,!1),this.chatStarted)throw new Error("A chat is already running. A call to endChat must be made before a new chat can start.");const{serviceManager:s}=this;try{this.chatStarted=!0,this.isHumanAgentTyping=!1,this.uploadingFiles.clear(),this.serviceManager.store.dispatch((0,o.cg)(this.uploadingFiles.size>0));const a={type:E.xp.HUMAN_AGENT_PRE_START_CHAT,message:t};if(await s.fire(a),a.cancelStartChat)return this.chatStarted=!1,await this.fireEndChat(!1,!0),void s.store.dispatch((0,o.np)(!1,null));const i=s.store.getState().config.public.serviceDesk?.agentJoinTimeoutSeconds;i&&(this.waitingForHumanAgentJoinedTimer=setTimeout(()=>this.handleHumanAgentJoinedTimeout(),1e3*i)),s.store.dispatch((0,o.np)(!0,e.ui_state.id)),await this.serviceDesk.startChat(t,{preStartChatPayload:a.preStartChatPayload})}catch(e){throw(0,l.yA)("[startChat] An error with the service desk occurred.",e),this.serviceDeskCallback&&await this.serviceDeskCallback.setErrorStatus({type:A.By.CONNECTING,logInfo:e}),s.store.dispatch((0,o.np)(!1,null)),this.chatStarted=!1,this.cancelHumanAgentJoinedTimer(),e}}async firePreEndChat(e){const t={type:E.xp.HUMAN_AGENT_PRE_END_CHAT,endedByHumanAgent:e,preEndChatPayload:null,cancelEndChat:!1};return await this.serviceManager.fire(t),t}async fireEndChat(e,t){await this.serviceManager.fire({type:E.xp.HUMAN_AGENT_END_CHAT,endedByHumanAgent:e,requestCancelled:t})}async endChat(e,t=!0,s=!0){if(!this.chatStarted||!this.serviceDesk)return;const{isConnected:a}=this.persistedHumanAgentState();let i;if(a&&(i=await this.firePreEndChat(!1),i.cancelEndChat))return;const r=e?I:L;await this.doEndChat(!1,i?.preEndChatPayload,t,s,r)}async doEndChat(e,t,s,a,i){const{isConnected:r}=this.persistedHumanAgentState(),n=this.isSuspended();this.cancelHumanAgentJoinedTimer(),this.closeScreenShareRequestModal(A.Ri.CANCELLED);try{await(0,d.$)(this.serviceDesk.endChat({endedByHumanAgent:e,preEndChatPayload:t}),5e3)}catch(e){(0,l.yA)("[doEndChat] An error with the service desk occurred.",e)}if(r&&s){const{responseUserProfile:e}=this.persistedHumanAgentState();await f(i,e,!0,n,this.serviceManager)}this.chatStarted=!1,this.isHumanAgentTyping=!1,this.serviceManager.store.dispatch((0,o._0)()),await this.fireEndChat(e,!r),r&&a&&await C(1500,n,this.serviceManager)}async sendMessageToAgent(e,t){if(!this.serviceDesk||!this.chatStarted)return;const{serviceManager:s}=this;(0,g.o)(t);const a=(0,u.r2)(e);a.input.agent_message_type=D,await s.fire({type:E.xp.HUMAN_AGENT_PRE_SEND,data:a,files:t});const i=(0,r.A)(a,a.input.text),n=i.ui_state.id,c=[];i.item.text&&c.push(M([i],a)),t.forEach(e=>{const t=(0,u.jS)(e),s=(0,r.A)(t,t.input.text,e.id);c.push(M([s],t)),this.uploadingFiles.add(e.id)}),this.serviceManager.store.dispatch((0,o.cg)(this.uploadingFiles.size>0)),await m(c,0,0,!this.isSuspended(),s);let d=!1,p=!1;setTimeout(()=>{d||p||this.setMessageErrorState(i.fullMessageID,h.J.RETRYING)},3e3),setTimeout(()=>{d||this.setMessageErrorState(i.fullMessageID,h.J.FAILED)},2e4);const A={filesToUpload:t};try{await this.serviceDesk.sendMessageToAgent(a,n,A),d=!0,this.setMessageErrorState(i.fullMessageID,h.J.NONE),await s.fire({type:E.xp.HUMAN_AGENT_SEND,data:a,files:t})}catch(e){p=!0,(0,l.yA)("[sendMessageToAgent] An error with the service desk occurred.",e),this.setMessageErrorState(i.fullMessageID,h.J.FAILED)}}filesSelectedForUpload(e){if(this.serviceDesk&&this.chatStarted)try{this.serviceDesk.filesSelectedForUpload?.(e)}catch(e){(0,l.yA)("[userReadMessages] An error with the service desk occurred.",e)}}async userReadMessages(){if(this.serviceDesk&&this.chatStarted)try{await this.serviceDesk.userReadMessages()}catch(e){(0,l.yA)("[userReadMessages] An error with the service desk occurred.",e)}}async checkAreAnyHumanAgentsOnline(e){let t;const s=this.serviceManager.restartCount;if(this.serviceDesk?.areAnyAgentsOnline)try{const s=this.serviceManager.store.getState().config.public.serviceDesk?.availabilityTimeoutSeconds,a=s?1e3*s:5e3,i=await(0,d.$)(this.serviceDesk.areAnyAgentsOnline(e),a);t=!0===i?A.L5.ONLINE:!1===i?A.L5.OFFLINE:A.L5.UNKNOWN}catch(e){(0,l.yA)("Error attempting to get agent availability",e),t=A.L5.OFFLINE}else t=A.L5.UNKNOWN;return s===this.serviceManager.restartCount&&this.serviceManager.fire({type:E.xp.HUMAN_AGENT_ARE_ANY_AGENTS_ONLINE,areAnyAgentsOnline:t}),t}async userTyping(e){if(this.serviceDesk&&this.chatStarted)try{await(this.serviceDesk.userTyping?.(e))}catch(e){(0,l.yA)("[userTyping] An error with the service desk occurred.",e)}}setMessageErrorState(e,t){this.serviceManager.store.dispatch(c.Ay.setMessageErrorState(e,t))}async handleHumanAgentJoinedTimeout(){const e=this.serviceManager.store.getState().languagePack.errors_noHumanAgentsJoined,{originalMessage:t,localMessage:s}=(0,n.fS)(e);await m([M([s],t)],0,0,!this.isSuspended(),this.serviceManager),this.endChat(!1)}cancelHumanAgentJoinedTimer(){this.waitingForHumanAgentJoinedTimer&&(clearTimeout(this.waitingForHumanAgentJoinedTimer),this.waitingForHumanAgentJoinedTimer=null)}async screenShareUpdateRequestState(e){if(!this.persistedHumanAgentState().isConnected)return;let t;switch(this.closeScreenShareRequestModal(e),e){case A.Ri.ACCEPTED:t=O;break;case A.Ri.DECLINED:t=G;break;case A.Ri.CANCELLED:t=F;break;case A.Ri.ENDED:t=q;break;default:return}await this.addHumanAgentLocalMessage(t)}async screenShareStop(){this.serviceManager.store.dispatch((0,o.F)(!1)),await this.addHumanAgentLocalMessage(q),await(this.serviceDesk?.screenShareStop?.())}async handleHydration(e,t){const{store:s}=this.serviceManager;let a=!1;const{isConnected:i}=this.persistedHumanAgentState();if(i){if(this.chatStarted=!0,e&&this.serviceDesk?.reconnect)try{s.dispatch((0,o.AF)(!0)),setTimeout(this.serviceManager.appWindow.requestFocus),a=await this.serviceDesk.reconnect()}catch(e){(0,l.yA)("Error while trying to reconnect to an agent.",e)}if(s.dispatch((0,o.AF)(!1)),!this.persistedHumanAgentState().isConnected)return void(this.chatStarted=!1);if(setTimeout(this.serviceManager.appWindow.requestFocus),a)this.showLeaveWarning=!1;else{this.chatStarted=!1;const e=this.isSuspended();if(s.dispatch((0,o._0)()),t){const{responseUserProfile:t}=this.persistedHumanAgentState();await f(y.iR.CHAT_WAS_ENDED,t,!1,e,this.serviceManager),await C(0,e,this.serviceManager)}}}}closeScreenShareRequestModal(e){this.serviceManager.store.dispatch((0,o.KT)(!1)),this.screenShareRequestPromise&&(this.screenShareRequestPromise.doResolve(e),this.screenShareRequestPromise=null),this.serviceManager.store.dispatch((0,o.F)(e===A.Ri.ACCEPTED))}async addHumanAgentLocalMessage(e,t,s=!0,a=!0){t||(t=this.persistedHumanAgentState().responseUserProfile);const{localMessage:i,originalMessage:r}=await _(e,this.serviceManager,t,s);await m([M([i],r)],0,0,!this.isSuspended(),this.serviceManager)}persistedHumanAgentState(){return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState}isSuspended(){return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState.isSuspended}}class x{constructor(e,t){this.serviceManager=e,this.service=t}updateCapabilities(e){this.serviceManager.store.dispatch((0,o.qb)((0,a.A)(e)))}async updateAgentAvailability(e){this.service.chatStarted&&this.serviceManager.store.dispatch((0,o.hB)(e))}async agentJoined(e){this.service.chatStarted&&(this.service.cancelHumanAgentJoinedTimer(),this.serviceManager.store.dispatch((0,o.gz)(e)),await this.service.addHumanAgentLocalMessage(k,e),this.service.showLeaveWarning&&(await this.service.addHumanAgentLocalMessage(U,null,!1,!1),this.service.showLeaveWarning=!1))}async agentReadMessages(){this.service.chatStarted&&(0,l.cY)("[ServiceDeskCallbackImpl] agentReadMessages")}async agentTyping(e){this.persistedHumanAgentState().isConnected&&e!==this.service.isHumanAgentTyping&&(this.serviceManager.store.dispatch((0,o.oP)(e)),this.service.isHumanAgentTyping=e)}async sendMessageToUser(e,t){if(!this.service.chatStarted||!e)return;const s="string"==typeof e?(0,u.Z2)(e):e;(0,u.Wf)(s),s.output?.generic?.length&&s.output.generic.forEach(e=>{e.agent_message_type||(e.agent_message_type=y.iR.FROM_HUMAN_AGENT)});const{serviceManager:a}=this;let i;void 0===t?i=this.persistedHumanAgentState().responseUserProfile:(i=this.persistedHumanAgentState().responseUserProfiles[t],i||(i=this.persistedHumanAgentState().responseUserProfile,i&&(0,l.yA)(`Got agent ID ${t} but no agent with that ID joined the conversation. Using the current agent instead.`))),await a.fire({type:E.xp.HUMAN_AGENT_PRE_RECEIVE,data:s,responseUserProfile:i}),s.history.response_user_profile=i;const r=s.output.generic.map(e=>(0,n.CL)(e,s));await m([M(r,s)],0,0,!this.service.isSuspended(),this.serviceManager),await a.fire({type:E.xp.HUMAN_AGENT_RECEIVE,data:s,responseUserProfile:i})}async beginTransferToAnotherAgent(e){this.service.chatStarted&&(e&&this.serviceManager.store.dispatch((0,o.gz)(e)),await this.service.addHumanAgentLocalMessage(b,e))}async agentLeftChat(){this.service.chatStarted&&(await this.service.addHumanAgentLocalMessage(P),this.service.isHumanAgentTyping=!1,this.serviceManager.store.dispatch((0,o.Sp)()))}async agentEndedChat(){if(!this.service.chatStarted)return;const e=await this.service.firePreEndChat(!0);e.cancelEndChat||await this.service.doEndChat(!0,e.preEndChatPayload,!0,!0,R)}async setErrorStatus(e){if(!this.service.chatStarted)return;const{type:t,logInfo:s}=e,{store:a}=this.serviceManager,{isConnecting:i}=a.getState().humanAgentState;switch(s&&(0,l.yA)(`An error occurred in the service desk (type=${t})`,s),i&&e.type===A.By.DISCONNECTED&&e.isDisconnected&&(e={type:A.By.CONNECTING}),e.type){case A.By.DISCONNECTED:e.isDisconnected?(this.service.showingDisconnectedError=!0,await this.service.addHumanAgentLocalMessage(H,null,!0,!1),a.dispatch(c.Ay.updateInputState({isReadonly:!0},!0))):this.service.showingDisconnectedError&&(this.service.showingDisconnectedError=!1,await this.service.addHumanAgentLocalMessage(w,null,!0,!1),a.dispatch(c.Ay.updateInputState({isReadonly:!1},!0)));break;case A.By.CONNECTING:{const{languagePack:t}=this.serviceManager.store.getState(),s=e.messageToUser||t.errors_connectingToHumanAgent,{originalMessage:a,localMessage:r}=(0,n.fS)(s);await m([M([r],a)],0,0,!this.service.isSuspended(),this.serviceManager),this.serviceManager.store.dispatch((0,o.np)(!1,null)),this.service.chatStarted=!1,this.service.cancelHumanAgentJoinedTimer(),await this.service.fireEndChat(!1,i);break}case A.By.USER_MESSAGE:this.service.setMessageErrorState(e.messageID,h.J.FAILED)}}async setFileUploadStatus(e,t,s){const{store:a}=this.serviceManager;if(a.getState().allMessagesByID[e])if(T.aT.COMPLETE,t){if(a.dispatch(c.Ay.setMessageHistoryProperty(e,"file_upload_status",T.aT.COMPLETE)),a.dispatch(c.Ay.setMessageHistoryProperty(e,"error_state",h.J.FAILED)),h.J.FAILED,s){const{originalMessage:e,localMessage:t}=(0,n.fS)(s);t.item.agent_message_type=y.iR.INLINE_ERROR,await m([M([t],e)],0,0,!this.service.isSuspended(),this.serviceManager)}}else a.dispatch(c.Ay.setMessageHistoryProperty(e,"file_upload_status",T.aT.SUCCESS)),a.dispatch(c.Ay.announceMessage({messageID:"fileSharing_ariaAnnounceSuccess"}));else t&&a.dispatch(c.Ay.fileUploadInputError(e,s,!0));this.service.uploadingFiles.delete(e),this.serviceManager.store.dispatch((0,o.cg)(this.service.uploadingFiles.size>0))}async screenShareRequest(){return this.persistedHumanAgentState().isConnected?(this.service.screenShareRequestPromise||(this.service.screenShareRequestPromise=(0,p.H)(),this.serviceManager.store.dispatch((0,o.KT)(!0)),await this.service.addHumanAgentLocalMessage(J)),this.service.screenShareRequestPromise):Promise.reject(new Error("Cannot request screen sharing if no chat is in progress."))}async screenShareEnded(){const e=this.serviceManager.store.getState().humanAgentState.isScreenSharing,t=this.service.screenShareRequestPromise;this.service.closeScreenShareRequestModal(A.Ri.CANCELLED),e?(this.serviceManager.store.dispatch((0,o.F)(!1)),await this.service.addHumanAgentLocalMessage(q)):t&&await this.service.addHumanAgentLocalMessage(F)}persistedHumanAgentState(){return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState}persistedState(){return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.humanAgentState.serviceDeskState}updatePersistedState(e,t=!0){const{store:s}=this.serviceManager;let r;r=t?(0,i.A)({},s.getState().persistedToBrowserStorage.chatState.humanAgentState.serviceDeskState,e):(0,a.A)(e),s.dispatch((0,o.HO)((0,g.o)(r)))}}function W(e){return new B(e)}}}]);
//# sourceMappingURL=2340.bundle.js.map