{"version":3,"file":"9816.bundle.js","mappings":";oJAuBA,SAASA,EAAeC,GACpB,MAAMC,EAAO,CACTC,IAAK,OACLC,MAAO,CACHC,KAAM,OACNC,IAAK,GACLC,QAAS,EACTC,MAAO,EACPC,QAAS,GACTC,MAAO,KACPC,SAAU,KACVC,OAAQ,GACRC,OAAO,EACPC,QAAQ,EACRC,IAAK,KACLC,KAAM,GACNC,KAAM,MAEVN,SAAU,IAGRO,EAAQ,CAAChB,GA2Bf,OA1BAD,EAAOkB,QAASf,IACZ,MAAMgB,EAAO,CACTjB,IAAKkB,EAAYjB,GACjBA,QACAO,SAAU,IAIK,WAAfP,EAAMC,MAAqBD,EAAMO,UAAUW,SAC3CF,EAAKT,SAAWX,EAAeI,EAAMO,UAAUA,UAEnD,MAAMY,EAAUL,EAAMA,EAAMI,OAAS,GACf,IAAlBlB,EAAMG,SAENgB,EAAQZ,SAASa,KAAKJ,GACtBF,EAAMM,KAAKJ,KAEa,IAAnBhB,EAAMG,QAEXW,EAAMO,MAINF,EAAQZ,SAASa,KAAKJ,KAGvBlB,CACX,CAMA,SAASmB,EAAYjB,GACjB,MAAMW,EAAMX,EAAMW,IAAMX,EAAMW,IAAIW,KAAK,KAAO,GAC9C,MAAO,GAAGtB,EAAMC,QAAQD,EAAME,OAAOS,GACzC,CAaA,SAASY,EAAcC,EAASC,GAG5B,IAAKD,GAAWA,EAAQzB,MAAQ0B,EAAQ1B,IACpC,OAAO0B,EAIX,MAAMC,EAAS,CACX3B,IAAK0B,EAAQ1B,IACbC,MAAOyB,EAAQzB,MACfO,SAAU,IAIRoB,EAAmB,IAAIC,IAAIJ,EAAQjB,SAASI,IAAKkB,GAAU,CAACA,EAAM9B,IAAK8B,KAgB7E,OAZAJ,EAAQlB,SAASQ,QAASe,IACtB,MAAMC,EAAWJ,EAAiBK,IAAIF,EAAS/B,KAE3CgC,EACAL,EAAOnB,SAASa,KAAKG,EAAcQ,EAAUD,IAI7CJ,EAAOnB,SAASa,KAAKU,KAItBJ,CACX,C","sources":["webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/web-components/components/markdownText/markdown/utils/tokenTree.js"],"sourcesContent":["/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\n/**\n * Converts a flat list of markdown-it tokens into a nested tree of TokenTrees.\n *\n * markdown-it returns a linear array of tokens that represent both block and inline\n * elements, including opening/closing tags and inline children. This function\n * reconstructs the intended hierarchical structure by walking the list and building\n * a tree based on token nesting levels.\n *\n * A stack is used to track the current node context. When an opening token is\n * encountered (nesting = 1), the function creates a node and pushes it onto the stack.\n * When a closing token is encountered (nesting = -1), the current context is popped.\n * Tokens with nesting = 0 are self-contained and added as children of the current node.\n *\n * Inline tokens are handled recursively by inspecting the `children` array.\n */\nfunction buildTokenTree(tokens) {\n    const root = {\n        key: \"root\",\n        token: {\n            type: \"root\",\n            tag: \"\",\n            nesting: 0,\n            level: 0,\n            content: \"\",\n            attrs: null,\n            children: null,\n            markup: \"\",\n            block: true,\n            hidden: false,\n            map: null,\n            info: \"\",\n            meta: null,\n        },\n        children: [],\n    };\n    // Stack keeps track of the current nesting level during traversal.\n    const stack = [root];\n    tokens.forEach((token) => {\n        const node = {\n            key: generateKey(token),\n            token,\n            children: [],\n        };\n        // Inline tokens may contain their own list of tokens in `children`.\n        // Recursively parse and attach those as this node's children.\n        if (token.type === \"inline\" && token.children?.length) {\n            node.children = buildTokenTree(token.children).children;\n        }\n        const current = stack[stack.length - 1];\n        if (token.nesting === 1) {\n            // Opening tag — add to current node and go deeper in the tree.\n            current.children.push(node);\n            stack.push(node);\n        }\n        else if (token.nesting === -1) {\n            // Closing tag — pop out of the current container.\n            stack.pop();\n        }\n        else {\n            // Flat token (e.g., text or self-contained element) — add to current level.\n            current.children.push(node);\n        }\n    });\n    return root;\n}\n/**\n * Generates a unique string key for a markdown-it token base on the starting and ending index of this block\n * and what markdown token type and tag that block maps to.\n * Used to help Lit’s `repeat()` directive track updates efficiently.\n */\nfunction generateKey(token) {\n    const map = token.map ? token.map.join(\"-\") : \"\";\n    return `${token.type}:${token.tag}:${map}`;\n}\n/**\n * This function compares two trees of tokens and tries to reuse as much of the old tree as possible when\n * the new tree looks the same.\n *\n * - If the top-level nodes have different keys, the entire thing changed, so return the new one.\n * - If the keys match, check the children of that node and reuse any unchanged ones.\n * - We do this by matching keys for each child.\n * - This function runs itself (recursively) for each child node. It's like going deeper into the tree.\n *\n * This function doesn't check every little detail - just the keys.\n *\n */\nfunction diffTokenTree(oldTree, newTree) {\n    // If the keys don’t match, it means this part of the tree is totally different,\n    // so we stop and just return the new one (no need to go deeper).\n    if (!oldTree || oldTree.key !== newTree.key) {\n        return newTree;\n    }\n    // If we get here, it means the keys match — so the structure is *probably* the same.\n    // We’ll create a new node, but reuse any children that are still the same.\n    const merged = {\n        key: newTree.key,\n        token: newTree.token,\n        children: [],\n    };\n    // Create a \"lookup table\" of old children using their keys.\n    // This helps us quickly find if a new child was already in the old tree.\n    const oldChildrenByKey = new Map(oldTree.children.map((child) => [child.key, child]));\n    // Now go through each new child and decide:\n    // - If it existed before (same key), reuse it by calling diffTokenTree again.\n    // - If it's totally new (new key), just use it.\n    newTree.children.forEach((newChild) => {\n        const oldChild = oldChildrenByKey.get(newChild.key);\n        // Reuse the old child if it exists, and keep diffing deeper into the tree\n        if (oldChild) {\n            merged.children.push(diffTokenTree(oldChild, newChild));\n        }\n        else {\n            // Otherwise, use the brand new child\n            merged.children.push(newChild);\n        }\n    });\n    // Return the final merged tree — it's a mix of reused and new pieces.\n    return merged;\n}\n\nexport { buildTokenTree, diffTokenTree };\n"],"names":["buildTokenTree","tokens","root","key","token","type","tag","nesting","level","content","attrs","children","markup","block","hidden","map","info","meta","stack","forEach","node","generateKey","length","current","push","pop","join","diffTokenTree","oldTree","newTree","merged","oldChildrenByKey","Map","child","newChild","oldChild","get"],"sourceRoot":""}