{"version":3,"file":"9816.bundle.js","mappings":";oJAQA,SAASA,EAAeC,GACtB,MAAMC,EAAO,CACXC,IAAK,OACLC,MAAO,CACLC,KAAM,OACNC,IAAK,GACLC,QAAS,EACTC,MAAO,EACPC,QAAS,GACTC,MAAO,KACPC,SAAU,KACVC,OAAQ,GACRC,OAAO,EACPC,QAAQ,EACRC,IAAK,KACLC,KAAM,GACNC,KAAM,MAERN,SAAU,IAENO,EAAQ,CAAEhB,GAoBhB,OAnBAD,EAAOkB,QAAQf,IACb,MAAMgB,EAAO,CACXjB,IAAKkB,EAAYjB,GACjBA,MAAOA,EACPO,SAAU,IAEO,WAAfP,EAAMC,MAAqBD,EAAMO,UAAUW,SAC7CF,EAAKT,SAAWX,EAAeI,EAAMO,UAAUA,UAEjD,MAAMY,EAAUL,EAAMA,EAAMI,OAAS,GACf,IAAlBlB,EAAMG,SACRgB,EAAQZ,SAASa,KAAKJ,GACtBF,EAAMM,KAAKJ,KACiB,IAAnBhB,EAAMG,QACfW,EAAMO,MAENF,EAAQZ,SAASa,KAAKJ,KAGnBlB,CACT,CAEA,SAASmB,EAAYjB,GACnB,MAAMW,EAAMX,EAAMW,IAAMX,EAAMW,IAAIW,KAAK,KAAO,GAC9C,MAAO,GAAGtB,EAAMC,QAAQD,EAAME,OAAOS,GACvC,CAEA,SAASY,EAAcC,EAASC,GAC9B,IAAKD,GAAWA,EAAQzB,MAAQ0B,EAAQ1B,IACtC,OAAO0B,EAET,MAAMC,EAAS,CACb3B,IAAK0B,EAAQ1B,IACbC,MAAOyB,EAAQzB,MACfO,SAAU,IAENoB,EAAmB,IAAIC,IAAIJ,EAAQjB,SAASI,IAAIkB,GAAS,CAAEA,EAAM9B,IAAK8B,KAS5E,OARAJ,EAAQlB,SAASQ,QAAQe,IACvB,MAAMC,EAAWJ,EAAiBK,IAAIF,EAAS/B,KAC3CgC,EACFL,EAAOnB,SAASa,KAAKG,EAAcQ,EAAUD,IAE7CJ,EAAOnB,SAASa,KAAKU,KAGlBJ,CACT,C","sources":["webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/web-components/components/markdownText/markdown/utils/tokenTree.js"],"sourcesContent":["/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\nfunction buildTokenTree(tokens) {\n  const root = {\n    key: \"root\",\n    token: {\n      type: \"root\",\n      tag: \"\",\n      nesting: 0,\n      level: 0,\n      content: \"\",\n      attrs: null,\n      children: null,\n      markup: \"\",\n      block: true,\n      hidden: false,\n      map: null,\n      info: \"\",\n      meta: null\n    },\n    children: []\n  };\n  const stack = [ root ];\n  tokens.forEach(token => {\n    const node = {\n      key: generateKey(token),\n      token: token,\n      children: []\n    };\n    if (token.type === \"inline\" && token.children?.length) {\n      node.children = buildTokenTree(token.children).children;\n    }\n    const current = stack[stack.length - 1];\n    if (token.nesting === 1) {\n      current.children.push(node);\n      stack.push(node);\n    } else if (token.nesting === -1) {\n      stack.pop();\n    } else {\n      current.children.push(node);\n    }\n  });\n  return root;\n}\n\nfunction generateKey(token) {\n  const map = token.map ? token.map.join(\"-\") : \"\";\n  return `${token.type}:${token.tag}:${map}`;\n}\n\nfunction diffTokenTree(oldTree, newTree) {\n  if (!oldTree || oldTree.key !== newTree.key) {\n    return newTree;\n  }\n  const merged = {\n    key: newTree.key,\n    token: newTree.token,\n    children: []\n  };\n  const oldChildrenByKey = new Map(oldTree.children.map(child => [ child.key, child ]));\n  newTree.children.forEach(newChild => {\n    const oldChild = oldChildrenByKey.get(newChild.key);\n    if (oldChild) {\n      merged.children.push(diffTokenTree(oldChild, newChild));\n    } else {\n      merged.children.push(newChild);\n    }\n  });\n  return merged;\n}\n\nexport { buildTokenTree, diffTokenTree };\n"],"names":["buildTokenTree","tokens","root","key","token","type","tag","nesting","level","content","attrs","children","markup","block","hidden","map","info","meta","stack","forEach","node","generateKey","length","current","push","pop","join","diffTokenTree","oldTree","newTree","merged","oldChildrenByKey","Map","child","newChild","oldChild","get"],"sourceRoot":""}