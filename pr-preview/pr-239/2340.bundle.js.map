{"version":3,"file":"2340.bundle.js","mappings":"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","sources":["webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/services/haa/humanAgentUtils.js","webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/services/haa/agentStatusMessage.js","webpack://@carbon/ai-chat-examples-demo/../packages/ai-chat/dist/es/chat/shared/services/haa/HumanAgentServiceImpl.js"],"sourcesContent":["import { BusEventType } from '../../../../types/events/eventBusTypes.js';\nimport { outputItemToLocalItem } from '../../schema/outputItemToLocalItem.js';\nimport actions from '../../store/actions.js';\nimport { conditionalSetTimeout } from '../../utils/browserUtils.js';\nimport { asyncForEach } from '../../utils/lang/arrayUtils.js';\nimport { deepFreeze } from '../../utils/lang/objectUtils.js';\nimport { createMessageResponseForItem } from '../../utils/messageUtils.js';\nimport { getAgentStatusMessageText } from './agentStatusMessage.js';\nimport { MessageResponseTypes } from '../../../../types/messaging/Messages.js';\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\n/**\n * Creates a LocalAndOriginalMessagesPair.\n */\nfunction toPair(localMessages, originalMessage) {\n    return { localMessages, originalMessage };\n}\n/**\n * Create a local message that represent a status message to display to the user.\n */\nasync function createAgentLocalMessage(agentMessageType, serviceManager, agentProfile, fireEvents = true) {\n    const text = getAgentStatusMessageText(agentMessageType, agentProfile, serviceManager.intl);\n    const result = createAgentLocalMessageForType(agentMessageType);\n    const { originalMessage, localMessage } = result;\n    localMessage.item.text = text;\n    if (agentProfile) {\n        if (!originalMessage.history) {\n            originalMessage.history = {};\n        }\n        originalMessage.history.agent_profile = agentProfile;\n    }\n    if (fireEvents) {\n        await serviceManager.fire({\n            type: BusEventType.AGENT_PRE_RECEIVE,\n            data: originalMessage,\n        });\n    }\n    deepFreeze(originalMessage);\n    if (fireEvents) {\n        await serviceManager.fire({\n            type: BusEventType.AGENT_RECEIVE,\n            data: originalMessage,\n        });\n    }\n    return result;\n}\n/**\n * Creates an empty skeleton of a {@link LocalMessageItem} with the given agent message type.\n */\nfunction createAgentLocalMessageForType(agentMessageType) {\n    const messageItem = {\n        response_type: MessageResponseTypes.TEXT,\n        agent_message_type: agentMessageType,\n    };\n    const originalMessage = createMessageResponseForItem(messageItem);\n    const localMessage = outputItemToLocalItem(messageItem, originalMessage);\n    return { localMessage, originalMessage };\n}\n/**\n * Creates a message for the \"bot returns\" message that is displayed after a chat is ended. If there is no text in\n * the language pack for this message, the message will be undefined.\n */\nfunction createBotReturnMessage(languagePack) {\n    // Create a bot message to let the user know the bot has returned.\n    const { agent_botReturned } = languagePack;\n    if (!agent_botReturned) {\n        // No text, so don't show anything.\n        return null;\n    }\n    const { originalMessage, localMessage } = createAgentLocalMessageForType(null);\n    localMessage.item.text = agent_botReturned;\n    return { originalMessage, localMessage };\n}\n/**\n * Adds the given messages to the redux store and optionally to session history as well.\n */\nasync function addMessages(messagePairs, saveInHistory, fireHistoryEvent, showLiveMessages, serviceManager) {\n    if (showLiveMessages) {\n        // Add to the redux store and fire any custom response events that are needed.\n        await asyncForEach(messagePairs, async ({ localMessages, originalMessage }) => {\n            await asyncForEach(localMessages, async (localMessage, index) => {\n                await serviceManager.actions.handleUserDefinedResponseItems(localMessage, originalMessage);\n                serviceManager.store.dispatch(actions.addLocalMessageItem(localMessage, originalMessage, index === 0));\n            });\n        });\n    }\n}\n/**\n * Adds a \"bot return\" message from the bot after (on an optional delay). This messages will also be sent to the server\n * to be included in the session history.\n *\n * @param botReturnDelay The delay before adding the \"bot return\" message.\n * @param wasSuspended Indicates if the conversation was suspended before it was ended.\n * @param serviceManager The service manager to use.\n */\nasync function addBotReturnMessage(botReturnDelay, wasSuspended, serviceManager) {\n    const botReturn = createBotReturnMessage(serviceManager.store.getState().languagePack);\n    if (botReturn) {\n        const initialRestartCount = serviceManager.restartCount;\n        conditionalSetTimeout(() => {\n            if (initialRestartCount === serviceManager.restartCount) {\n                // Don't show this message if the chat has been restarted since we started waiting.\n                addMessages([toPair([botReturn.localMessage], botReturn.originalMessage)], true, false, !wasSuspended, serviceManager);\n            }\n        }, botReturnDelay);\n    }\n}\n/**\n * Adds an \"end chat\" message to the message list. This messages will also be sent to the server to be included in the\n * session history.\n *\n * @param agentMessageType The type of the \"end chat\" message.\n * @param agentProfile The profile of the agent who ended the chat (or null if not ended by an agent).\n * @param fireEvents Indicates if the agent events should be fired for the \"end chat\" message.\n * @param wasSuspended Indicates if the conversation was suspended before it was ended.\n * @param serviceManager The service manager to use.\n */\nasync function addAgentEndChatMessage(agentMessageType, agentProfile, fireEvents, wasSuspended, serviceManager) {\n    const endChatMessage = await createAgentLocalMessage(agentMessageType, serviceManager, agentProfile, fireEvents);\n    await addMessages([toPair([endChatMessage.localMessage], endChatMessage.originalMessage)], true, false, !wasSuspended, serviceManager);\n}\n\nexport { addAgentEndChatMessage, addBotReturnMessage, addMessages, createAgentLocalMessage, toPair };\n","import { AgentMessageType } from '../../../../types/messaging/Messages.js';\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\n/**\n * Calculates the text to display for a given agent message type.\n */\nfunction getAgentStatusMessageText(agentMessageType, agentProfile, intl) {\n    const name = agentProfile?.nickname;\n    let messageKey;\n    switch (agentMessageType) {\n        case AgentMessageType.AGENT_JOINED: {\n            messageKey = name ? \"agent_agentJoinedName\" : \"agent_agentJoinedNoName\";\n            break;\n        }\n        case AgentMessageType.RELOAD_WARNING: {\n            messageKey = \"agent_youConnectedWarning\";\n            break;\n        }\n        case AgentMessageType.AGENT_LEFT_CHAT: {\n            messageKey = name ? \"agent_agentLeftChat\" : \"agent_agentLeftChatNoName\";\n            break;\n        }\n        case AgentMessageType.AGENT_ENDED_CHAT: {\n            messageKey = name ? \"agent_agentEndedChat\" : \"agent_agentEndedChatNoName\";\n            break;\n        }\n        case AgentMessageType.TRANSFER_TO_AGENT: {\n            messageKey = name ? \"agent_transferring\" : \"agent_transferringNoName\";\n            break;\n        }\n        case AgentMessageType.USER_ENDED_CHAT: {\n            messageKey = \"agent_youEndedChat\";\n            break;\n        }\n        case AgentMessageType.CHAT_WAS_ENDED: {\n            messageKey = \"agent_conversationWasEnded\";\n            break;\n        }\n        case AgentMessageType.DISCONNECTED: {\n            messageKey = \"agent_disconnected\";\n            break;\n        }\n        case AgentMessageType.RECONNECTED: {\n            messageKey = \"agent_reconnected\";\n            break;\n        }\n        case AgentMessageType.SHARING_REQUESTED: {\n            messageKey = \"agent_sharingRequested\";\n            break;\n        }\n        case AgentMessageType.SHARING_ACCEPTED: {\n            messageKey = \"agent_sharingAccepted\";\n            break;\n        }\n        case AgentMessageType.SHARING_DECLINED: {\n            messageKey = \"agent_sharingDeclined\";\n            break;\n        }\n        case AgentMessageType.SHARING_CANCELLED: {\n            messageKey = \"agent_sharingCancelled\";\n            break;\n        }\n        case AgentMessageType.SHARING_ENDED: {\n            messageKey = \"agent_sharingEnded\";\n            break;\n        }\n        default:\n            return \"\";\n    }\n    return (messageKey && intl.formatMessage({ id: messageKey }, { personName: name }));\n}\n\nexport { getAgentStatusMessageText };\n","import cloneDeep from 'lodash-es/cloneDeep.js';\nimport merge from 'lodash-es/merge.js';\nimport inputItemToLocalItem from '../../schema/inputItemToLocalItem.js';\nimport { createLocalMessageForInlineError, outputItemToLocalItem } from '../../schema/outputItemToLocalItem.js';\nimport actions from '../../store/actions.js';\nimport { updateFilesUploadInProgress, setIsConnecting, endChat, setIsScreenSharing, setIsReconnecting, setShowScreenShareRequest, updateCapabilities, setAgentAvailability, setAgentJoined, agentUpdateIsTyping, setAgentLeftChat, setPersistedServiceDeskState } from '../../store/agentActions.js';\nimport { MessageErrorState } from '../../../../types/messaging/LocalMessageItem.js';\nimport '../../utils/constants.js';\nimport { deepFreeze } from '../../utils/lang/objectUtils.js';\nimport { resolveOrTimeout } from '../../utils/lang/promiseUtils.js';\nimport { createMessageRequestForText, createMessageRequestForFileUpload, createMessageResponseForText, addDefaultsToMessage } from '../../utils/messageUtils.js';\nimport { debugLog, consoleError } from '../../utils/miscUtils.js';\nimport { resolvablePromise } from '../../utils/resolvablePromise.js';\nimport { ErrorType, ScreenShareState, AgentsOnlineStatus } from '../../../../types/config/ServiceDeskConfig.js';\nimport { addAgentEndChatMessage, addBotReturnMessage, addMessages, toPair, createAgentLocalMessage } from './humanAgentUtils.js';\nimport { AgentMessageType } from '../../../../types/messaging/Messages.js';\nimport { BusEventType } from '../../../../types/events/eventBusTypes.js';\nimport { FileStatusValue } from '../../../../types/instance/apiTypes.js';\n\n/*\n *  Copyright IBM Corp. 2025\n *\n *  This source code is licensed under the Apache-2.0 license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  @license\n */\n/**\n * The amount of time to wait when a message is sent to the service desk before displaying a warning if the service\n * desk doesn't indicate the message was received.\n */\nconst SEND_TIMEOUT_WARNING_MS = 3000;\n/**\n * The amount of time to wait when a message is sent to the service desk before displaying an error if the service\n * desk doesn't indicate the message was received.\n */\nconst SEND_TIMEOUT_ERROR_MS = 20000;\n/**\n * The amount of time to wait before an attempt to end a chat times out, and we close it anyway.\n */\nconst END_CHAT_TIMEOUT_MS = 5000;\n/**\n * The amount of time to wait before a check for agent availability times out if there's no answer.\n */\nconst AVAILABILITY_TIMEOUT_MS = 5000;\n/**\n * The amount of time to wait before displaying the \"bot returns\" message.\n */\nconst BOT_RETURN_DELAY = 1500;\nconst { FROM_USER, RECONNECTED, DISCONNECTED, AGENT_ENDED_CHAT, AGENT_JOINED, USER_ENDED_CHAT, CHAT_WAS_ENDED, TRANSFER_TO_AGENT, AGENT_LEFT_CHAT, RELOAD_WARNING, SHARING_CANCELLED, SHARING_DECLINED, SHARING_ACCEPTED, SHARING_REQUESTED, SHARING_ENDED, } = AgentMessageType;\nclass HumanAgentServiceImpl {\n    constructor(serviceManager) {\n        /**\n         * Indicates if a chat has started (the startChat function has been called). It does not necessarily mean that an\n         * agent has joined and a full chat is in progress.\n         */\n        this.chatStarted = false;\n        /**\n         * Indicates if the service desk has gotten into a disconnected error state.\n         */\n        this.showingDisconnectedError = false;\n        /**\n         * Indicates if an agent is currently typing.\n         */\n        this.isAgentTyping = false;\n        /**\n         * The current set of files that are being uploaded.\n         */\n        this.uploadingFiles = new Set();\n        /**\n         * We only want to show the refresh/leave warning when the first agent joins, so we use this boolean to track if the\n         * warning has been shown.\n         */\n        this.showLeaveWarning = true;\n        this.serviceManager = serviceManager;\n    }\n    /**\n     * If a custom service desk is configured, returns the name.\n     */\n    getCustomServiceDeskName() {\n        return this.serviceManager.store.getState().config.public.serviceDeskFactory\n            ? this.serviceDesk.getName?.()\n            : undefined;\n    }\n    /**\n     * Initializes this service. This will create the service desk instance that can be used for communicating with\n     * service desks.\n     */\n    async initialize() {\n        if (this.serviceDesk) {\n            throw new Error(\"A service desk has already been created!\");\n        }\n        const { store, instance } = this.serviceManager;\n        const state = store.getState();\n        const { config, persistedToBrowserStorage } = state;\n        const serviceDeskState = cloneDeep(persistedToBrowserStorage.chatState.agentState.serviceDeskState);\n        this.serviceDeskCallback = new ServiceDeskCallbackImpl(this.serviceManager, this);\n        if (config.public.serviceDeskFactory) {\n            // A custom service desk factory was provided so use that to create the service desk.\n            const parameters = {\n                callback: this.serviceDeskCallback,\n                instance,\n                persistedState: serviceDeskState,\n            };\n            this.serviceDesk = await config.public.serviceDeskFactory(parameters);\n            validateCustomServiceDesk(this.serviceDesk);\n            debugLog(\"Initializing a custom service desk\");\n        }\n        // If the service desk supports reconnecting, we don't need to show this warning.\n        this.showLeaveWarning = !this.serviceDesk?.reconnect;\n    }\n    /**\n     * Begins a chat between the current user and the currently configured service desk. This may not be called if\n     * there is already a service desk being used.\n     *\n     * @param localConnectMessage The specific localMessage caused the connection to an agent. It will\n     * contain specific information to send to the service desk as part of the connection. This can include things\n     * like a message to display to a human agent.\n     * @param originalMessage The full original message that this Connect to Agent item belongs to.\n     */\n    async startChat(localConnectMessage, originalMessage) {\n        if (!this.serviceDesk) {\n            // No service desk connected.\n            throw new Error(\"A service desk has not been configured.\");\n        }\n        if (this.serviceManager.store.getState().persistedToBrowserStorage.chatState\n            .agentState.isSuspended) {\n            // If the user is currently engaged in a conversation with an agent that is suspended and we start a new chat, we\n            // need to end the current conversation first. We do still want to generate the \"agent left\" message however but\n            // not the \"bot return\" message that occurs on a delay.\n            await this.endChat(true, true, false);\n        }\n        if (this.chatStarted) {\n            throw new Error(\"A chat is already running. A call to endChat must be made before a new chat can start.\");\n        }\n        const { serviceManager } = this;\n        try {\n            this.chatStarted = true;\n            this.isAgentTyping = false;\n            this.uploadingFiles.clear();\n            this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.uploadingFiles.size > 0));\n            // Fire off the pre-start event.\n            const event = {\n                type: BusEventType.AGENT_PRE_START_CHAT,\n                message: originalMessage,\n            };\n            await serviceManager.fire(event);\n            if (event.cancelStartChat) {\n                // Abort the connecting.\n                this.chatStarted = false;\n                await this.fireEndChat(false, true);\n                serviceManager.store.dispatch(setIsConnecting(false, null));\n                return;\n            }\n            const agentJoinTimeout = serviceManager.store.getState().config.public.serviceDesk\n                ?.agentJoinTimeoutSeconds;\n            if (agentJoinTimeout) {\n                this.waitingForAgentJoinedTimer = setTimeout(() => this.handleAgentJoinedTimeout(), agentJoinTimeout * 1000);\n            }\n            serviceManager.store.dispatch(setIsConnecting(true, localConnectMessage.ui_state.id));\n            await this.serviceDesk.startChat(originalMessage, {\n                preStartChatPayload: event.preStartChatPayload,\n            });\n        }\n        catch (error) {\n            consoleError(\"[startChat] An error with the service desk occurred.\", error);\n            // If it failed to start, then stop connecting and clear the service desk.\n            if (this.serviceDeskCallback) {\n                await this.serviceDeskCallback.setErrorStatus({\n                    type: ErrorType.CONNECTING,\n                    logInfo: error,\n                });\n            }\n            serviceManager.store.dispatch(setIsConnecting(false, null));\n            this.chatStarted = false;\n            this.cancelAgentJoinedTimer();\n            throw error;\n        }\n    }\n    /**\n     * Fires the {@link BusEventType.AGENT_PRE_END_CHAT} event. The event fired is returned which can contain information\n     * added by a listener.\n     */\n    async firePreEndChat(endedByAgent) {\n        // Before ending the chat, fire an event.\n        const event = {\n            type: BusEventType.AGENT_PRE_END_CHAT,\n            endedByAgent,\n            preEndChatPayload: null,\n            cancelEndChat: false,\n        };\n        await this.serviceManager.fire(event);\n        return event;\n    }\n    /**\n     * Fires the {@link BusEventType.AGENT_END_CHAT} event.\n     */\n    async fireEndChat(endedByAgent, requestCancelled) {\n        // Before ending the chat, fire an event.\n        await this.serviceManager.fire({\n            type: BusEventType.AGENT_END_CHAT,\n            endedByAgent,\n            requestCancelled,\n        });\n    }\n    /**\n     * Tells the service desk to terminate the chat.\n     *\n     * @param endedByUser Indicates if the chat is being ended as a result of the user or if it was ended\n     * programmatically from an instance method.\n     * @param showAgentLeftMessage Indicates if the chat should show the \"agent left\" message.\n     * @param showBotReturnMessage Indicates if the chat should show the \"bot return\" message.\n     * @returns Returns a Promise that resolves when the service desk has successfully handled the call.\n     */\n    async endChat(endedByUser, showAgentLeftMessage = true, showBotReturnMessage = true) {\n        if (!this.chatStarted || !this.serviceDesk) {\n            // Already ended or no service desk.\n            return;\n        }\n        const { isConnected } = this.persistedAgentState();\n        let event;\n        if (isConnected) {\n            event = await this.firePreEndChat(false);\n            if (event.cancelEndChat) {\n                return;\n            }\n        }\n        const endMessageType = endedByUser ? USER_ENDED_CHAT : CHAT_WAS_ENDED;\n        await this.doEndChat(false, event?.preEndChatPayload, showAgentLeftMessage, showBotReturnMessage, endMessageType);\n    }\n    /**\n     * This function will end the chat with a service class and clear the service state for it.\n     */\n    async doEndChat(endedByAgent, preEndChatPayload, showAgentLeftMessage, showBotReturnMessage, agentEndChatMessageType) {\n        const { isConnected } = this.persistedAgentState();\n        const wasSuspended = this.isSuspended();\n        this.cancelAgentJoinedTimer();\n        this.closeScreenShareRequestModal(ScreenShareState.CANCELLED);\n        try {\n            await resolveOrTimeout(this.serviceDesk.endChat({ endedByAgent, preEndChatPayload }), END_CHAT_TIMEOUT_MS);\n        }\n        catch (error) {\n            consoleError(\"[doEndChat] An error with the service desk occurred.\", error);\n        }\n        if (isConnected && showAgentLeftMessage) {\n            const { agentProfile } = this.persistedAgentState();\n            await addAgentEndChatMessage(agentEndChatMessageType, agentProfile, true, wasSuspended, this.serviceManager);\n        }\n        this.chatStarted = false;\n        this.isAgentTyping = false;\n        this.serviceManager.store.dispatch(endChat());\n        await this.fireEndChat(endedByAgent, !isConnected);\n        if (isConnected && showBotReturnMessage) {\n            await addBotReturnMessage(BOT_RETURN_DELAY, wasSuspended, this.serviceManager);\n        }\n    }\n    /**\n     * Sends a message to the agent in the service desk.\n     *\n     * @param text The message from the user.\n     * @param uploads An optional set of files to upload.\n     * @returns Returns a Promise that resolves when the service desk has successfully handled the call.\n     */\n    async sendMessageToAgent(text, uploads) {\n        if (!this.serviceDesk || !this.chatStarted) {\n            // No service desk connected.\n            return;\n        }\n        const { serviceManager } = this;\n        deepFreeze(uploads);\n        const originalMessage = createMessageRequestForText(text);\n        originalMessage.input.agent_message_type = FROM_USER;\n        // Fire the pre:send event that will allow code to customize the message.\n        await serviceManager.fire({\n            type: BusEventType.AGENT_PRE_SEND,\n            data: originalMessage,\n            files: uploads,\n        });\n        // Add the outgoing message to the store immediately.\n        const textMessage = inputItemToLocalItem(originalMessage, originalMessage.input.text);\n        const localMessageID = textMessage.ui_state.id;\n        const pairs = [];\n        if (textMessage.item.text) {\n            pairs.push(toPair([textMessage], originalMessage));\n        }\n        // Add a message for each file upload.\n        uploads.forEach((upload) => {\n            // Note that we're going to reuse the file ID for the MessageRequest and LocalMessage to make it easier to\n            // locate the objects when we need to update their states.\n            const uploadOriginalMessage = createMessageRequestForFileUpload(upload);\n            const uploadLocalMessage = inputItemToLocalItem(uploadOriginalMessage, uploadOriginalMessage.input.text, upload.id);\n            pairs.push(toPair([uploadLocalMessage], uploadOriginalMessage));\n            this.uploadingFiles.add(upload.id);\n        });\n        this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.uploadingFiles.size > 0));\n        await addMessages(pairs, true, true, !this.isSuspended(), serviceManager);\n        // Start some timeouts to display a warning or error if the service desk doesn't indicate if the message was\n        // sent successfully (or it failed).\n        let messageSucceeded = false;\n        let messageFailed = false;\n        setTimeout(() => {\n            if (!messageSucceeded && !messageFailed) {\n                this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.RETRYING);\n            }\n        }, SEND_TIMEOUT_WARNING_MS);\n        setTimeout(() => {\n            if (!messageSucceeded) {\n                this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.FAILED);\n            }\n        }, SEND_TIMEOUT_ERROR_MS);\n        const additionalData = {\n            filesToUpload: uploads,\n        };\n        try {\n            // Send the message to the service desk.\n            await this.serviceDesk.sendMessageToAgent(originalMessage, localMessageID, additionalData);\n            messageSucceeded = true;\n            this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.NONE);\n            await serviceManager.fire({\n                type: BusEventType.AGENT_SEND,\n                data: originalMessage,\n                files: uploads,\n            });\n        }\n        catch (error) {\n            messageFailed = true;\n            consoleError(\"[sendMessageToAgent] An error with the service desk occurred.\", error);\n            this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.FAILED);\n        }\n    }\n    /**\n     * Indicates that the user has selected some files to be uploaded but that the user has not yet chosen to send\n     * them to the agent.\n     */\n    filesSelectedForUpload(uploads) {\n        if (!this.serviceDesk || !this.chatStarted) {\n            // No service desk connected.\n            return;\n        }\n        try {\n            this.serviceDesk.filesSelectedForUpload?.(uploads);\n        }\n        catch (error) {\n            consoleError(\"[userReadMessages] An error with the service desk occurred.\", error);\n        }\n    }\n    /**\n     * Informs the service desk that the user has read all the messages that have been sent by the service desk.\n     */\n    async userReadMessages() {\n        if (!this.serviceDesk || !this.chatStarted) {\n            // No service desk connected.\n            return;\n        }\n        try {\n            await this.serviceDesk.userReadMessages();\n        }\n        catch (error) {\n            consoleError(\"[userReadMessages] An error with the service desk occurred.\", error);\n        }\n    }\n    /**\n     * Checks if any agents are online and ready to communicate with the user. This function will time out after 5\n     * seconds and will return false when that happens.\n     *\n     * @param connectMessage The message that contains the transfer_info object that may be used by the service desk,\n     * so it can perform a more specific check.\n     */\n    async checkAreAnyAgentsOnline(connectMessage) {\n        let resultValue;\n        const initialRestartCount = this.serviceManager.restartCount;\n        if (!this.serviceDesk?.areAnyAgentsOnline) {\n            resultValue = AgentsOnlineStatus.UNKNOWN;\n        }\n        else {\n            try {\n                const timeoutSeconds = this.serviceManager.store.getState().config.public.serviceDesk\n                    ?.availabilityTimeoutSeconds;\n                const timeout = timeoutSeconds\n                    ? timeoutSeconds * 1000\n                    : AVAILABILITY_TIMEOUT_MS;\n                const result = await resolveOrTimeout(this.serviceDesk.areAnyAgentsOnline(connectMessage), timeout);\n                if (result === true) {\n                    resultValue = AgentsOnlineStatus.ONLINE;\n                }\n                else if (result === false) {\n                    resultValue = AgentsOnlineStatus.OFFLINE;\n                }\n                else {\n                    // Any other value for result will return an unknown status.\n                    resultValue = AgentsOnlineStatus.UNKNOWN;\n                }\n            }\n            catch (error) {\n                consoleError(\"Error attempting to get agent availability\", error);\n                // If we fail to get an answer we'll just return false to indicate that no agents are available.\n                resultValue = AgentsOnlineStatus.OFFLINE;\n            }\n        }\n        if (initialRestartCount === this.serviceManager.restartCount) {\n            // Don't await this since we don't want any event handlers to hold up this check.\n            this.serviceManager.fire({\n                type: BusEventType.AGENT_ARE_ANY_AGENTS_ONLINE,\n                areAnyAgentsOnline: resultValue,\n            });\n        }\n        return resultValue;\n    }\n    /**\n     * Tells the service desk if a user has started or stopped typing.\n     *\n     * @param isTyping If true, indicates that the user is typing. False indicates the user has stopped typing.\n     */\n    async userTyping(isTyping) {\n        if (!this.serviceDesk || !this.chatStarted) {\n            // No service desk connected.\n            return;\n        }\n        try {\n            await this.serviceDesk.userTyping?.(isTyping);\n        }\n        catch (error) {\n            consoleError(\"[userTyping] An error with the service desk occurred.\", error);\n        }\n    }\n    /**\n     * Sets the error state for the message with the given id.\n     *\n     * @param messageID The ID of the message to set the state for. This will be the ID that was passed on the service\n     * desk as part of the {@link ServiceDesk#sendMessageToAgent} call.\n     * @param errorState The state to set of the message.\n     */\n    setMessageErrorState(messageID, errorState) {\n        this.serviceManager.store.dispatch(actions.setMessageErrorState(messageID, errorState));\n    }\n    /**\n     * This is called when an agent fails to join a chat after a given period of time.\n     */\n    async handleAgentJoinedTimeout() {\n        // Display an error to the user.\n        const message = this.serviceManager.store.getState().languagePack.errors_noAgentsJoined;\n        const { originalMessage, localMessage } = createLocalMessageForInlineError(message);\n        await addMessages([toPair([localMessage], originalMessage)], true, false, !this.isSuspended(), this.serviceManager);\n        // End the chat.\n        this.endChat(false);\n    }\n    /**\n     * Cancels the agent joined timer if one is running.\n     */\n    cancelAgentJoinedTimer() {\n        if (this.waitingForAgentJoinedTimer) {\n            clearTimeout(this.waitingForAgentJoinedTimer);\n            this.waitingForAgentJoinedTimer = null;\n        }\n    }\n    /**\n     * Informs the service desk of a change in the state of screen sharing from the user side.\n     *\n     * @param state The new state of the screen sharing.\n     */\n    async screenShareUpdateRequestState(state) {\n        if (!this.persistedAgentState().isConnected) {\n            // Not connected to an agent.\n            return;\n        }\n        // Close the modal.\n        this.closeScreenShareRequestModal(state);\n        let agentMessageType;\n        switch (state) {\n            case ScreenShareState.ACCEPTED:\n                agentMessageType = SHARING_ACCEPTED;\n                break;\n            case ScreenShareState.DECLINED:\n                agentMessageType = SHARING_DECLINED;\n                break;\n            case ScreenShareState.CANCELLED:\n                agentMessageType = SHARING_CANCELLED;\n                break;\n            case ScreenShareState.ENDED:\n                agentMessageType = SHARING_ENDED;\n                break;\n            default:\n                return;\n        }\n        // Display a message to the user.\n        await this.addAgentLocalMessage(agentMessageType);\n    }\n    /**\n     * Informs the service desk that it should stop screen sharing.\n     */\n    async screenShareStop() {\n        this.serviceManager.store.dispatch(setIsScreenSharing(false));\n        await this.addAgentLocalMessage(SHARING_ENDED);\n        await this.serviceDesk?.screenShareStop?.();\n    }\n    /**\n     * Called during the hydration process to allow the service to deal with hydration.\n     */\n    async handleHydration(allowReconnect, allowEndChatMessages) {\n        const { store } = this.serviceManager;\n        let didReconnect = false;\n        const { isConnected } = this.persistedAgentState();\n        if (isConnected) {\n            this.chatStarted = true;\n            if (allowReconnect && this.serviceDesk?.reconnect) {\n                // If the user was previously connected to an agent, we need to see if we can reconnect the user to the agent.\n                try {\n                    store.dispatch(setIsReconnecting(true));\n                    setTimeout(this.serviceManager.appWindow.requestFocus);\n                    // Let the service desk do whatever it needs to do to reconnect.\n                    didReconnect = await this.serviceDesk.reconnect();\n                }\n                catch (error) {\n                    consoleError(`Error while trying to reconnect to an agent.`, error);\n                }\n            }\n            store.dispatch(setIsReconnecting(false));\n            if (!this.persistedAgentState().isConnected) {\n                // The user may have disconnected while waiting for the reconnect in which case, just stop what we're doing.\n                this.chatStarted = false;\n                return;\n            }\n            setTimeout(this.serviceManager.appWindow.requestFocus);\n            if (!didReconnect) {\n                // If we didn't reconnected, then just end the chat.\n                this.chatStarted = false;\n                const wasSuspended = this.isSuspended();\n                store.dispatch(endChat());\n                if (allowEndChatMessages) {\n                    // If we didn't reconnect, then show the \"end chat\" messages to the user.\n                    const { agentProfile } = this.persistedAgentState();\n                    await addAgentEndChatMessage(AgentMessageType.CHAT_WAS_ENDED, agentProfile, false, wasSuspended, this.serviceManager);\n                    await addBotReturnMessage(0, wasSuspended, this.serviceManager);\n                }\n            }\n            else {\n                this.showLeaveWarning = false;\n            }\n        }\n    }\n    /**\n     * Closes the screen share request modal and completes the promise waiting on it.\n     */\n    closeScreenShareRequestModal(state) {\n        // Close the modal if it was open.\n        this.serviceManager.store.dispatch(setShowScreenShareRequest(false));\n        // If someone is waiting on the Promise, then resolve it.\n        if (this.screenShareRequestPromise) {\n            this.screenShareRequestPromise.doResolve(state);\n            this.screenShareRequestPromise = null;\n        }\n        this.serviceManager.store.dispatch(setIsScreenSharing(state === ScreenShareState.ACCEPTED));\n    }\n    /**\n     * Adds a local agent message.\n     */\n    async addAgentLocalMessage(agentMessageType, agentProfile, fireEvents = true, saveInHistory = true) {\n        if (!agentProfile) {\n            agentProfile = this.persistedAgentState().agentProfile;\n        }\n        const { localMessage, originalMessage } = await createAgentLocalMessage(agentMessageType, this.serviceManager, agentProfile, fireEvents);\n        await addMessages([toPair([localMessage], originalMessage)], saveInHistory, false, !this.isSuspended(), this.serviceManager);\n    }\n    /**\n     * Returns the persisted agent state from the store.\n     */\n    persistedAgentState() {\n        return this.serviceManager.store.getState().persistedToBrowserStorage\n            .chatState.agentState;\n    }\n    /**\n     * Indicates if the conversation with the agent is suspended.\n     */\n    isSuspended() {\n        return this.serviceManager.store.getState().persistedToBrowserStorage\n            .chatState.agentState.isSuspended;\n    }\n}\n/**\n * This class implements the callback that is passed to the service desk that it can use to send us information that\n * it produced by the service desk.\n */\nclass ServiceDeskCallbackImpl {\n    constructor(serviceManager, service) {\n        this.serviceManager = serviceManager;\n        this.service = service;\n    }\n    /**\n     * Updates Carbon AI chat with the capabilities supported by the service desk. Some of these capabilities may support\n     * being changed dynamically and can be updated at any time.\n     *\n     * @param capabilities The set of capabilities to update. Only properties that need to be changed need to be included.\n     */\n    updateCapabilities(capabilities) {\n        this.serviceManager.store.dispatch(updateCapabilities(cloneDeep(capabilities)));\n    }\n    /**\n     * Sends updated availability information to the chat widget for a user who is waiting to be connected to an\n     * agent. This may be called at any point while waiting for the connection to provide newer information.\n     *\n     * @param availability The availability information to display to the user.\n     */\n    async updateAgentAvailability(availability) {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        this.serviceManager.store.dispatch(setAgentAvailability(availability));\n    }\n    /**\n     * Informs the chat widget that the agent has read all the messages that have been sent to the service desk.\n     */\n    async agentJoined(profile) {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        this.service.cancelAgentJoinedTimer();\n        // Update the store with the current agent's profile information.\n        this.serviceManager.store.dispatch(setAgentJoined(profile));\n        // Then generate a message we can display in the UI to indicate that the agent has joined.\n        await this.service.addAgentLocalMessage(AGENT_JOINED, profile);\n        if (this.service.showLeaveWarning) {\n            await this.service.addAgentLocalMessage(RELOAD_WARNING, null, false, false);\n            this.service.showLeaveWarning = false;\n        }\n    }\n    /**\n     * Informs the chat widget that the agent has read all the messages that have been sent to the service desk.\n     *\n     * This functionality is not yet implemented.\n     */\n    async agentReadMessages() {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        debugLog(\"[ServiceDeskCallbackImpl] agentReadMessages\");\n    }\n    /**\n     * Tells the chat widget if an agent has started or stopped typing.\n     *\n     * @param isTyping If true, indicates that the agent is typing. False indicates the agent has stopped typing.\n     */\n    async agentTyping(isTyping) {\n        if (this.persistedAgentState().isConnected &&\n            isTyping !== this.service.isAgentTyping) {\n            this.serviceManager.store.dispatch(agentUpdateIsTyping(isTyping));\n            this.service.isAgentTyping = isTyping;\n        }\n    }\n    /**\n     * Sends a message to the chat widget from an agent.\n     *\n     * Note: The text response type from the standard Watson API is supported in addition to the Carbon AI chat specific\n     * {@link MessageResponseTypes.INLINE_ERROR} response type.\n     *\n     * @param message The message to display to the user. Note, the ability to pass a string for the message was added in\n     * Carbon AI chat 6.7.0. Earlier versions of Carbon AI chat will not work if you pass just a string.\n     * @param agentID The ID of the agent who is sending the message. If this is not provided, then the ID of the last\n     * agent who joined the conversation will be used.\n     */\n    async sendMessageToUser(message, agentID) {\n        if (!this.service.chatStarted || !message) {\n            // The chat is no longer running or no message was actually provided.\n            return;\n        }\n        const messageResponse = typeof message === \"string\"\n            ? createMessageResponseForText(message)\n            : message;\n        addDefaultsToMessage(messageResponse);\n        if (messageResponse.output?.generic?.length) {\n            messageResponse.output.generic.forEach((messageItem) => {\n                if (!messageItem.agent_message_type) {\n                    messageItem.agent_message_type = AgentMessageType.FROM_AGENT;\n                }\n            });\n        }\n        const { serviceManager } = this;\n        // If no agent ID is provided, just use the current one.\n        let agentProfile;\n        if (agentID === undefined) {\n            agentProfile = this.persistedAgentState().agentProfile;\n        }\n        else {\n            agentProfile = this.persistedAgentState().agentProfiles[agentID];\n            if (!agentProfile) {\n                // If we don't have a profile for the agent who sent this message, we need to use the profile for the current\n                // agent (if there is one).\n                agentProfile = this.persistedAgentState().agentProfile;\n                if (agentProfile) {\n                    consoleError(`Got agent ID ${agentID} but no agent with that ID joined the conversation. Using the current agent instead.`);\n                }\n            }\n        }\n        // Fire the pre:receive event that will allow code to customize the message.\n        await serviceManager.fire({\n            type: BusEventType.AGENT_PRE_RECEIVE,\n            data: messageResponse,\n            agentProfile,\n        });\n        messageResponse.history.agent_profile = agentProfile;\n        const localMessages = messageResponse.output.generic.map((item) => {\n            return outputItemToLocalItem(item, messageResponse);\n        });\n        await addMessages([toPair(localMessages, messageResponse)], true, true, !this.service.isSuspended(), this.serviceManager);\n        await serviceManager.fire({\n            type: BusEventType.AGENT_RECEIVE,\n            data: messageResponse,\n            agentProfile,\n        });\n    }\n    /**\n     * Informs the chat widget that a transfer to another agent is in progress. The agent profile information is\n     * optional if the service desk doesn't have the information available. This message simply tells the chat widget\n     * that the transfer has started. The service desk should inform the widget when the transfer is complete by\n     * sending a {@link agentJoined} message later.\n     */\n    async beginTransferToAnotherAgent(profile) {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        if (profile) {\n            // Update the store with the current agent's profile information.\n            this.serviceManager.store.dispatch(setAgentJoined(profile));\n        }\n        await this.service.addAgentLocalMessage(TRANSFER_TO_AGENT, profile);\n    }\n    /**\n     * Informs the chat widget that the current agent has left the conversation.\n     */\n    async agentLeftChat() {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        await this.service.addAgentLocalMessage(AGENT_LEFT_CHAT);\n        this.service.isAgentTyping = false;\n        this.serviceManager.store.dispatch(setAgentLeftChat());\n    }\n    /**\n     * Informs the chat widget that the agent has closed the conversation.\n     */\n    async agentEndedChat() {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        const event = await this.service.firePreEndChat(true);\n        if (event.cancelEndChat) {\n            return;\n        }\n        await this.service.doEndChat(true, event.preEndChatPayload, true, true, AGENT_ENDED_CHAT);\n    }\n    /**\n     * Sets the state of the given error type.\n     *\n     * @param errorInfo Details for the error whose state is being set.\n     */\n    async setErrorStatus(errorInfo) {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        const { type, logInfo } = errorInfo;\n        const { store } = this.serviceManager;\n        const { isConnecting } = store.getState().agentState;\n        if (logInfo) {\n            consoleError(`An error occurred in the service desk (type=${type})`, logInfo);\n        }\n        // If the service desk reports a disconnected error while we're in the middle of connecting, then handle it as a\n        // connecting error instead. This avoids us sending the user a message when we never actually connected.\n        if (isConnecting &&\n            errorInfo.type === ErrorType.DISCONNECTED &&\n            errorInfo.isDisconnected) {\n            errorInfo = { type: ErrorType.CONNECTING };\n        }\n        switch (errorInfo.type) {\n            case ErrorType.DISCONNECTED: {\n                if (errorInfo.isDisconnected) {\n                    // The service desk has become disconnected so show an error and don't allow the user to send messages.\n                    this.service.showingDisconnectedError = true;\n                    await this.service.addAgentLocalMessage(DISCONNECTED, null, true, false);\n                    store.dispatch(actions.updateInputState({ isReadonly: true }, true));\n                }\n                else if (this.service.showingDisconnectedError) {\n                    // The service desk says it's no longer disconnected but double check that we previously thought we were\n                    // disconnected.\n                    this.service.showingDisconnectedError = false;\n                    await this.service.addAgentLocalMessage(RECONNECTED, null, true, false);\n                    store.dispatch(actions.updateInputState({ isReadonly: false }, true));\n                }\n                break;\n            }\n            case ErrorType.CONNECTING: {\n                // If we can't connect, display an inline error message on the bot view.\n                const { languagePack } = this.serviceManager.store.getState();\n                const message = errorInfo.messageToUser || languagePack.errors_connectingToAgent;\n                const { originalMessage, localMessage } = createLocalMessageForInlineError(message);\n                await addMessages([toPair([localMessage], originalMessage)], true, false, !this.service.isSuspended(), this.serviceManager);\n                // Cancel the connecting status.\n                this.serviceManager.store.dispatch(setIsConnecting(false, null));\n                this.service.chatStarted = false;\n                this.service.cancelAgentJoinedTimer();\n                await this.service.fireEndChat(false, isConnecting);\n                break;\n            }\n            case ErrorType.USER_MESSAGE: {\n                this.service.setMessageErrorState(errorInfo.messageID, MessageErrorState.FAILED);\n                break;\n            }\n        }\n    }\n    /**\n     * Updates the status of a file upload. The upload may either be successful or an error may have occurred. The\n     * location of a file upload may be in one of two places. The first occurs when the user has selected a file to be\n     * uploaded but has not yet sent the file. In this case, the file appears inside the Carbon AI chat input area. If an\n     * error is indicated on the file, the error message will be displayed along with the file and the user must\n     * remove the file from the input area before a message can be sent.\n     *\n     * The second occurs after the user has sent the file and the service desk has begun to upload the file. In this\n     * case, the file no longer appears in the input area but appears as a sent message in the message list. If an\n     * error occurs during this time, an icon will appear next to the message to indicate an error occurred and an\n     * error message will be added to the message list.\n     *\n     * @param fileID The ID of the file upload to update.\n     * @param isError Indicates that the upload has an error or failed to upload.\n     * @param errorMessage An error message to display along with a file in error.\n     */\n    async setFileUploadStatus(fileID, isError, errorMessage) {\n        const { store } = this.serviceManager;\n        // First we need to determine if the file upload has been sent or not. A message will exist in the store if so;\n        // otherwise the file upload only exists in the input area.\n        const uploadMessage = store.getState().allMessagesByID[fileID];\n        if (uploadMessage) {\n            // Update the value in the redux store.\n            ({\n                history: { file_upload_status: FileStatusValue.COMPLETE },\n            });\n            if (isError) {\n                store.dispatch(actions.setMessageHistoryProperty(fileID, \"file_upload_status\", FileStatusValue.COMPLETE));\n                store.dispatch(actions.setMessageHistoryProperty(fileID, \"error_state\", MessageErrorState.FAILED));\n                MessageErrorState.FAILED;\n                if (errorMessage) {\n                    // Generate an inline error message to show the error to the user.\n                    const { originalMessage, localMessage } = createLocalMessageForInlineError(errorMessage);\n                    localMessage.item.agent_message_type = AgentMessageType.INLINE_ERROR;\n                    await addMessages([toPair([localMessage], originalMessage)], true, true, !this.service.isSuspended(), this.serviceManager);\n                }\n            }\n            else {\n                // If the upload was completed successfully, we display a temporary \"success\" status. This will display a\n                // checkmark temporarily before fading out. Session history will store \"complete\" as the status.\n                store.dispatch(actions.setMessageHistoryProperty(fileID, \"file_upload_status\", FileStatusValue.SUCCESS));\n                store.dispatch(actions.announceMessage({\n                    messageID: \"fileSharing_ariaAnnounceSuccess\",\n                }));\n            }\n        }\n        else if (isError) {\n            // Update the input area.\n            store.dispatch(actions.fileUploadInputError(fileID, errorMessage, true));\n        }\n        this.service.uploadingFiles.delete(fileID);\n        this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.service.uploadingFiles.size > 0));\n    }\n    /**\n     * Requests that the user share their screen with the agent. This will present a modal dialog to the user who must\n     * respond before continuing the conversation. This method returns a Promise that resolves when the user has\n     * responded to the request or the request times out.\n     *\n     * @returns Returns a Promise that will resolve with the state the of the request. This Promise will reject if no\n     * chat with an agent is currently running.\n     */\n    async screenShareRequest() {\n        if (!this.persistedAgentState().isConnected) {\n            return Promise.reject(new Error(\"Cannot request screen sharing if no chat is in progress.\"));\n        }\n        if (!this.service.screenShareRequestPromise) {\n            this.service.screenShareRequestPromise = resolvablePromise();\n            this.serviceManager.store.dispatch(setShowScreenShareRequest(true));\n            await this.service.addAgentLocalMessage(SHARING_REQUESTED);\n        }\n        return this.service.screenShareRequestPromise;\n    }\n    /**\n     * Informs Carbon AI chat that a screen sharing session has ended or been cancelled. This may occur while waiting for a\n     * screen sharing request to be accepted or while screen sharing is in progress.\n     */\n    async screenShareEnded() {\n        const wasScreenSharing = this.serviceManager.store.getState().agentState.isScreenSharing;\n        const requestPending = this.service.screenShareRequestPromise;\n        this.service.closeScreenShareRequestModal(ScreenShareState.CANCELLED);\n        if (wasScreenSharing) {\n            this.serviceManager.store.dispatch(setIsScreenSharing(false));\n            await this.service.addAgentLocalMessage(SHARING_ENDED);\n        }\n        else if (requestPending) {\n            await this.service.addAgentLocalMessage(SHARING_CANCELLED);\n        }\n    }\n    /**\n     * Returns the persisted agent state from the store.\n     */\n    persistedAgentState() {\n        return this.serviceManager.store.getState().persistedToBrowserStorage\n            .chatState.agentState;\n    }\n    /**\n     * Returns the persisted service desk state from the store. This is the current state as updated by\n     * {@link updatePersistedState}. The object returned here is frozen and may not be modified.\n     */\n    persistedState() {\n        return this.serviceManager.store.getState().persistedToBrowserStorage\n            .chatState.agentState.serviceDeskState;\n    }\n    /**\n     * Allows the service desk to store state that may be retrieved when Carbon AI chat is reloaded on a page. This information\n     * is stored in browser session storage which has a total limit of 5MB per origin so the storage should be used\n     * sparingly. Also, the value provided here must be JSON serializable.\n     *\n     * When Carbon AI chat is reloaded, the data provided here will be returned to the service desk via the\n     * ServiceDeskFactoryParameters.persistedState property.\n     *\n     * @param state The state to update.\n     * @param mergeWithCurrent Indicates if the new state should be merged into the existing state. If false, then the\n     * existing state will be fully replaced with the new state. Merging with existing state expects the state to be\n     * an object.\n     */\n    updatePersistedState(state, mergeWithCurrent = true) {\n        const { store } = this.serviceManager;\n        let newState;\n        if (mergeWithCurrent) {\n            newState = merge({}, store.getState().persistedToBrowserStorage.chatState.agentState\n                .serviceDeskState, state);\n        }\n        else {\n            newState = cloneDeep(state);\n        }\n        store.dispatch(setPersistedServiceDeskState(deepFreeze(newState)));\n    }\n}\n/**\n * Returns a new instance of the service implementation.\n */\nfunction createService(serviceManager) {\n    return new HumanAgentServiceImpl(serviceManager);\n}\n/**\n * Performs some minimal validation of the provided custom service desk to make sure it meets the minimum\n * requirements. This simply checks that the service desk has the required properties and that those properties are\n * functions. If there are any errors, they are logged to the console.\n */\nfunction validateCustomServiceDesk(serviceDesk) {\n    if (!serviceDesk) {\n        consoleError(\"The custom service desk does not appear to be valid. No service desk was provided.\", serviceDesk);\n    }\n    else if (typeof serviceDesk !== \"object\") {\n        consoleError(`The custom service desk does not appear to be valid. The type should be \"object\" but is \"${typeof serviceDesk}\"`, serviceDesk);\n    }\n    else {\n        const propertyNames = [\n            \"startChat\",\n            \"endChat\",\n            \"sendMessageToAgent\",\n        ];\n        propertyNames.forEach((propertyName) => {\n            const value = serviceDesk[propertyName];\n            if (typeof value !== \"function\") {\n                consoleError(`The custom service desk does not appear to be valid. The type of property \"${propertyName}\"should be \"function\" but is \"${typeof value}\"`, value, serviceDesk);\n            }\n        });\n        const name = serviceDesk.getName?.();\n        if (!name) {\n            throw Error(\"The custom service desk does not have a name.\");\n        }\n        if (name && (typeof name !== \"string\" || name.length > 40)) {\n            throw new Error(`The custom service desk name \"${name}\" is not valid.`);\n        }\n    }\n}\n\nexport { HumanAgentServiceImpl, createService, validateCustomServiceDesk };\n"],"names":["toPair","localMessages","originalMessage","async","createAgentLocalMessage","agentMessageType","serviceManager","agentProfile","fireEvents","text","intl","name","nickname","messageKey","AgentMessageType","AGENT_JOINED","RELOAD_WARNING","AGENT_LEFT_CHAT","AGENT_ENDED_CHAT","TRANSFER_TO_AGENT","USER_ENDED_CHAT","CHAT_WAS_ENDED","DISCONNECTED","RECONNECTED","SHARING_REQUESTED","SHARING_ACCEPTED","SHARING_DECLINED","SHARING_CANCELLED","SHARING_ENDED","formatMessage","id","personName","getAgentStatusMessageText","result","createAgentLocalMessageForType","localMessage","item","history","agent_profile","fire","type","BusEventType","AGENT_PRE_RECEIVE","data","deepFreeze","AGENT_RECEIVE","messageItem","response_type","MessageResponseTypes","TEXT","agent_message_type","createMessageResponseForItem","outputItemToLocalItem","addMessages","messagePairs","saveInHistory","fireHistoryEvent","showLiveMessages","asyncForEach","index","actions","handleUserDefinedResponseItems","store","dispatch","addLocalMessageItem","addBotReturnMessage","botReturnDelay","wasSuspended","botReturn","languagePack","agent_botReturned","createBotReturnMessage","getState","initialRestartCount","restartCount","conditionalSetTimeout","addAgentEndChatMessage","endChatMessage","FROM_USER","HumanAgentServiceImpl","constructor","this","chatStarted","showingDisconnectedError","isAgentTyping","uploadingFiles","Set","showLeaveWarning","getCustomServiceDeskName","config","public","serviceDeskFactory","serviceDesk","getName","undefined","initialize","Error","instance","state","persistedToBrowserStorage","serviceDeskState","cloneDeep","chatState","agentState","serviceDeskCallback","ServiceDeskCallbackImpl","parameters","callback","persistedState","consoleError","forEach","propertyName","value","length","validateCustomServiceDesk","debugLog","reconnect","startChat","localConnectMessage","isSuspended","endChat","clear","updateFilesUploadInProgress","size","event","AGENT_PRE_START_CHAT","message","cancelStartChat","fireEndChat","setIsConnecting","agentJoinTimeout","agentJoinTimeoutSeconds","waitingForAgentJoinedTimer","setTimeout","handleAgentJoinedTimeout","ui_state","preStartChatPayload","error","setErrorStatus","ErrorType","CONNECTING","logInfo","cancelAgentJoinedTimer","firePreEndChat","endedByAgent","AGENT_PRE_END_CHAT","preEndChatPayload","cancelEndChat","requestCancelled","AGENT_END_CHAT","endedByUser","showAgentLeftMessage","showBotReturnMessage","isConnected","persistedAgentState","endMessageType","doEndChat","agentEndChatMessageType","closeScreenShareRequestModal","ScreenShareState","CANCELLED","resolveOrTimeout","sendMessageToAgent","uploads","createMessageRequestForText","input","AGENT_PRE_SEND","files","textMessage","inputItemToLocalItem","localMessageID","pairs","push","upload","uploadOriginalMessage","createMessageRequestForFileUpload","uploadLocalMessage","add","messageSucceeded","messageFailed","setMessageErrorState","fullMessageID","MessageErrorState","RETRYING","FAILED","additionalData","filesToUpload","NONE","AGENT_SEND","filesSelectedForUpload","userReadMessages","checkAreAnyAgentsOnline","connectMessage","resultValue","areAnyAgentsOnline","timeoutSeconds","availabilityTimeoutSeconds","timeout","AgentsOnlineStatus","ONLINE","OFFLINE","UNKNOWN","AGENT_ARE_ANY_AGENTS_ONLINE","userTyping","isTyping","messageID","errorState","errors_noAgentsJoined","createLocalMessageForInlineError","clearTimeout","screenShareUpdateRequestState","ACCEPTED","DECLINED","ENDED","addAgentLocalMessage","screenShareStop","setIsScreenSharing","handleHydration","allowReconnect","allowEndChatMessages","didReconnect","setIsReconnecting","appWindow","requestFocus","setShowScreenShareRequest","screenShareRequestPromise","doResolve","service","updateCapabilities","capabilities","updateAgentAvailability","availability","setAgentAvailability","agentJoined","profile","setAgentJoined","agentReadMessages","agentTyping","agentUpdateIsTyping","sendMessageToUser","agentID","messageResponse","createMessageResponseForText","addDefaultsToMessage","output","generic","FROM_AGENT","agentProfiles","map","beginTransferToAnotherAgent","agentLeftChat","setAgentLeftChat","agentEndedChat","errorInfo","isConnecting","isDisconnected","updateInputState","isReadonly","messageToUser","errors_connectingToAgent","USER_MESSAGE","setFileUploadStatus","fileID","isError","errorMessage","allMessagesByID","FileStatusValue","COMPLETE","setMessageHistoryProperty","INLINE_ERROR","SUCCESS","announceMessage","fileUploadInputError","delete","screenShareRequest","resolvablePromise","Promise","reject","screenShareEnded","wasScreenSharing","isScreenSharing","requestPending","updatePersistedState","mergeWithCurrent","newState","merge","setPersistedServiceDeskState","createService"],"sourceRoot":""}